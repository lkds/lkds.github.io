<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>找数字</title>
    <link href="/2021/03/04/%E6%89%BE%E6%95%B0%E5%AD%97/"/>
    <url>/2021/03/04/%E6%89%BE%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a></h2><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><p><strong>提示：</strong></p><ul><li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li><li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</li></ul><p><strong>示例 1：</strong></p><blockquote><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：00000000000000000000000010000000<br>输出：1<br>解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：11111111111111111111111111111101<br>输出：31<br>解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。 </p></blockquote><p><strong>提示：</strong></p><p>输入必须是长度为 32 的 二进制串。</p><h3 id="逐个数"><a href="#逐个数" class="headerlink" title="逐个数"></a>逐个数</h3><p>直观思想，与1做按位与，如果为1，那么最低位为1，否则为0，然后右移一位，循环32次得到结果</p><h3 id="n-amp-（n-1）"><a href="#n-amp-（n-1）" class="headerlink" title="n&amp;（n-1）"></a>n&amp;（n-1）</h3><p>分析一下n-1，n-1会将一个数上的最低的1变为0，同时将后面的全部变为1，这样导致的结果就是该位和后面的位都与原来的数字不同，那么只要做一下按位与操作就可以消除不同的位，造成了最低位1的消除，重复操作直到原来的数字变为0，计算一共操作的次数，就可以计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h2><p>使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。</p><ul><li>任何数和 0 做异或运算，结果仍然是原来的数，即a⊕0=a。</li><li>任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</li><li>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数</a></h2><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)<br><strong>示例 1：</strong></p><blockquote><p>输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2] </p></blockquote><p><strong>限制：</strong></p><p><code>2 &lt;= nums.length &lt;= 10000</code></p><h3 id="初试异或"><a href="#初试异或" class="headerlink" title="初试异或"></a>初试异或</h3><p>当存在两个不同的数字时，对所有数进行异或的结果是得到了$x\oplus y$，但是只有这个还无法得到x和y的具体值，因此需要额外的运算</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>显然，如果能将原数组分为两部分[x,…], [y,…]，即将x和y划分到两个数组中，同时满足只有一个数不同。<br>如何分组成为关键，我们需要将重复了两次的数分到同样的组，但是不用管具体是哪一个组，同时要将x和y分到不同的组，因此要找到xy之间不同，但是在同样的两个数字上相同的特征，这就要从数字本身下手。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>任意一个正整数都对应一个二进制表示，任意两个不同的数，一定存在某一个位二进制不同，同时对于同样的数，任意对应位一定相同，因此可以根据这个特性分组。</p><ul><li>找到x和y不相同的一位，生成一个只有该位为1的数记为m，具体的<ul><li>计算异或得到$x\oplus y$</li><li>遍历其二进制的每一位，看是否为1（异或性质，0同1异）<ul><li>可以使用 0001， 0010， 0100， 1000等与其做按位与操作快速判断，从1开始右移位循环</li></ul></li></ul></li><li>对数组中的每一个数，将其与m按位与，如果<ul><li>结果为0，表示这个数该位为0，分到一边</li><li>结果为1，表示这个数改为为1，分到另一边</li><li>分别对两边的数进行异或得到结果（实际上可以同步进行）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        n, m, x, y = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            n ^= num</span><br><span class="line">        <span class="keyword">while</span> n &amp; m == <span class="number">0</span>:</span><br><span class="line">            m &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &amp; m:</span><br><span class="line">                x ^= num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y ^= num</span><br><span class="line">        <span class="keyword">return</span> [x, y]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II</a></h2><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。<br><strong>示例 1：</strong></p><blockquote><p>输入：nums = [3,4,3,3]<br>输出：4</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [9,1,7,9,7,9,7]<br>输出：1 </p></blockquote><p><strong>限制：</strong></p><ul><li>1 &lt;= nums.length &lt;= 10000</li><li>1 &lt;= nums[i] &lt; 2^31</li></ul><h3 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h3><p>如果一个数出现了三次，那么将其每位上的二进制数相加再对3取余，那么取出来都是0，如果但是只出现一次的就将保持不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        counts = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">                counts[i] += num &amp; <span class="number">1</span> <span class="comment"># 更新第 i 位 1 的个数之和</span></span><br><span class="line">                num &gt;&gt;= <span class="number">1</span>            <span class="comment"># 第 i 位 --&gt; 第 i 位</span></span><br><span class="line">        res, m = <span class="number">0</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            res &lt;&lt;= <span class="number">1</span></span><br><span class="line">            res |= counts[i] % m     <span class="comment"># 恢复第 i 位</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> counts[<span class="number">31</span>] % m == <span class="number">0</span> <span class="keyword">else</span> ~(res ^ <span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>上述方法需要疯狂遍历，但是如果对每一位使用状态机，也就是32位，每一位都遍历一遍数组，遵循以下规则<br>0-1-2-0-1-2-…-<br>就可以缩减空间</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>二进制</tag>
      
      <tag>异或</tag>
      
      <tag>位运算</tag>
      
      <tag>查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雾里祈祷,旅途的终点并非无法企及</title>
    <link href="/2021/02/22/%E9%9B%BE%E9%87%8C%E7%A5%88%E7%A5%B7-%E6%97%85%E9%80%94%E7%9A%84%E7%BB%88%E7%82%B9%E5%B9%B6%E9%9D%9E%E6%97%A0%E6%B3%95%E4%BC%81%E5%8F%8A/"/>
    <url>/2021/02/22/%E9%9B%BE%E9%87%8C%E7%A5%88%E7%A5%B7-%E6%97%85%E9%80%94%E7%9A%84%E7%BB%88%E7%82%B9%E5%B9%B6%E9%9D%9E%E6%97%A0%E6%B3%95%E4%BC%81%E5%8F%8A/</url>
    
    <content type="html"><![CDATA[<p><strong>前言</strong><br>没什么特别的原因，如果要说缘由自然是有一堆，也挑不出一个头绪来。<br>我要为<code>春物</code>作传已经没有很久了，也没有一直在想，倒是随性地冒出一个这样地法子，甚至连要胡言乱语些什么都毫无头绪。说到底，只是无畏地、无谓地敲敲打打，缝缝补补。<br>不会妄图在平滑的墙上撕开一个口子遁入纸片世界，企望思绪的联通能穿透空间的束缚，至少在脑中有个印记。</p><hr><p>终点，他举起手指着来自西方的太阳。追逐它，西边的尽头就是终点。一个声音从未名的方向传来，那一刻，比企谷八幡似乎看到了他希望的脑中的结局。<br>成田的风迎送一茬一茬的人离开，相聚。每一架客机小心地试探着，任何异动都牵扯着机组与地服的神经。<br>雪之下不关心这些，尽管她也会望着西去的飞机露出沉思的面容，但往往都会被周围的声音惊扰。那是免税店里传出来的，虽然早就听闻过成田免税店的名声，但是亲自到时又是另一种情况了。雪乃并不想进去，她似乎没有要去买什么的理由，但又在期待着什么东西。<br>一只手从她的手臂滑过，落在了她的手心，没有丝毫的犹豫，她便握住了，被牵着走进了店里。</p><blockquote><p>走，我倒要看看大名鼎鼎的免税店里有些什么</p></blockquote><p>与其说雪之下不想进到店里去，倒不如说她不想主动进到店里去。从来，她都不是一个主动的人，她从心底里认定了这一点。</p><blockquote><p>好多外国人啊</p></blockquote><blockquote><p>是啊，好像大部分都是中国来的</p></blockquote><blockquote><p>说起来，在这里，我们倒成了外国人了<br>这里的东西我不常见过，说是免税店，价格倒也不便宜</p></blockquote><blockquote><p>大多是都是化妆品，你见得少也不算奇怪<br>虽然看上去不便宜，但其实真的是便宜了不少呢</p></blockquote><p>比企谷又随意看了看几件商品的价签和周围的游客，似乎确信了中国人很有钱的言论了。他没有注意到，雪之下已经脱离了他的手掌，正四处逛着，好像她也变成了从异国他乡来的旅人，满眼都是踏入他国的新奇和欣喜。虽然他和她也正要踏上一场未知的旅行，但他的内心却没有太大的波动。<br>反观雪之下，一直以来她的生活都是衣食无忧的，旅行这种东西或许对她来说已经是家常便饭了吧。可是依然像一个不谙世事的小孩，急切地想要触碰一切。</p><blockquote><p>你经常去旅行吗</p></blockquote><blockquote><p>也没有很经常吧，我不是很喜欢陌生的地方。</p></blockquote><blockquote><p>嗯哼？</p></blockquote><blockquote><p>没有，我的意思是，以前的时候</p></blockquote><p>比企谷没有说话，只是用他的死鱼眼盯着雪乃，雪乃注意到了这一股目光，却也没有说话，只是脸颊比刚才稍微要红了一些。</p><blockquote><p>这个烟上面有熊猫欸，好像是中国产的</p></blockquote><p>显然，雪之下想要掩饰尴尬，才找了这样的仓皇的理由，尽管她真的喜欢熊猫，但是显然不是香烟盒子上的。</p><blockquote><p>我还没有体会过吞云吐雾的感觉呢</p></blockquote><blockquote><p>不要</p></blockquote><p>说罢，雪之下的脸更红了，便拉着比企谷快步走出了门店</p><blockquote><p>去看看是不是要起飞了吧</p></blockquote><p>日起东方又被薄雾所盖，小窗里逐渐微缩的世界，在游离的光与影中透过小窗瞥见一切，向终点飞去。</p><p><strong>后记</strong><br>短篇的东西最能让执笔的人动心，又最难让读到的人动心，索性也不会有所想法，便搁置种种长途浩瀚，止笔于此。</p>]]></content>
    
    
    <categories>
      
      <category>文辞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>雪之下雪乃</tag>
      
      <tag>比企谷八幡</tag>
      
      <tag>春物</tag>
      
      <tag>同人</tag>
      
      <tag>试验</tag>
      
      <tag>重庆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1438. 绝对差不超过限制的最长连续子数组</title>
    <link href="/2021/02/21/1438.%20%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2021/02/21/1438.%20%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h2><p>给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p><p>如果不存在满足条件的子数组，则返回 0 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums = [8,2,4,7], limit = 4<br>输出：2<br>解释：所有子数组如下：<br>[8] 最大绝对差 |8-8| = 0 &lt;= 4.<br>[8,2] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.<br>[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.<br>[2] 最大绝对差 |2-2| = 0 &lt;= 4.<br>[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.<br>[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.<br>[4] 最大绝对差 |4-4| = 0 &lt;= 4.<br>[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.<br>[7] 最大绝对差 |7-7| = 0 &lt;= 4.<br>因此，满足题意的最长子数组的长度为 2 。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums = [10,1,2,4,7,2], limit = 5<br>输出：4<br>解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums = [4,2,2,2,4,4,2,2], limit = 0<br>输出：3 </p></blockquote><p><strong>提示：</strong></p><blockquote><p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i] &lt;= 10^9<br>0 &lt;= limit &lt;= 10^9</p></blockquote><p>通过次数<strong>10,059</strong><br>提交次数<strong>24,298</strong></p><h3 id="传统功夫"><a href="#传统功夫" class="headerlink" title="传统功夫"></a>传统功夫</h3><p>显然，题目很容易懂，第一时间能想到的就是维护一个滑动窗口，计算窗口内的绝对值的最大值，如果超过了限制，就将窗口等长右移，否则只将右边界右移使窗口扩大一位，直到数组末尾结束。在滑动过程中计算最大长度。</p><p>关键问题在于如何寻找绝对值的最大值，首先想到的就是排序后比较最大和最小值，但是这样比较复杂而且存在超时的风险。因为不仅仅需要排序，还存在这元素的插入与删除，因此需要的操作成本较高。</p><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>平衡树可以在查找元素和保持有序之间达到一个比较好的性能，因为其插入和删除是默认有序的。那么可以用这样的容器替代上述功能。</p><ul><li>C++ std::multiset</li><li>Python sortedcontainers.SortedList</li><li>Java TreeMap</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s = SortedList()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = right = ret = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            s.add(nums[right])</span><br><span class="line">            <span class="keyword">while</span> s[-<span class="number">1</span>] - s[<span class="number">0</span>] &gt; limit:</span><br><span class="line">                s.remove(nums[left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            ret = <span class="built_in">max</span>(ret, right - left + <span class="number">1</span>)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>所谓单调队列，即保持有序的队列，利用<code>queue</code>手动实现</p><ul><li>单调增（从小到大）：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="keyword">while</span>(!d.<span class="built_in">empty</span>() &amp;&amp; d.<span class="built_in">back</span>() &lt; x)&#123;</span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">d.<span class="built_in">push_back</span>(x)</span><br></pre></td></tr></table></figure></li><li>单调减反之</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        queMax, queMin = deque(), deque()</span><br><span class="line">        left = right = ret = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="keyword">while</span> queMax <span class="keyword">and</span> queMax[-<span class="number">1</span>] &lt; nums[right]:</span><br><span class="line">                queMax.pop()</span><br><span class="line">            <span class="keyword">while</span> queMin <span class="keyword">and</span> queMin[-<span class="number">1</span>] &gt; nums[right]:</span><br><span class="line">                queMin.pop()</span><br><span class="line">            </span><br><span class="line">            queMax.append(nums[right])</span><br><span class="line">            queMin.append(nums[right])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> queMax <span class="keyword">and</span> queMin <span class="keyword">and</span> queMax[<span class="number">0</span>] - queMin[<span class="number">0</span>] &gt; limit:</span><br><span class="line">                <span class="keyword">if</span> nums[left] == queMin[<span class="number">0</span>]:</span><br><span class="line">                    queMin.popleft()</span><br><span class="line">                <span class="keyword">if</span> nums[left] == queMax[<span class="number">0</span>]:</span><br><span class="line">                    queMax.popleft()</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ret = <span class="built_in">max</span>(ret, right - left + <span class="number">1</span>)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>单调队列</tag>
      
      <tag>数组</tag>
      
      <tag>子数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>995.K连续位的最小翻转次数</title>
    <link href="/2021/02/18/1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/"/>
    <url>/2021/02/18/1178-%E7%8C%9C%E5%AD%97%E8%B0%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="1178-猜字谜"><a href="#1178-猜字谜" class="headerlink" title="1178. 猜字谜"></a><a href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/">1178. 猜字谜</a></h2><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p><ul><li>单词 word 中包含谜面 puzzle 的第一个字母。</li><li>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。</li></ul><p>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong><br>words = [“aaaa”,”asas”,”able”,”ability”,”actt”,”actor”,”access”],<br>puzzles = [“aboveyz”,”abrodyz”,”abslute”,”absoryz”,”actresz”,”gaswxyz”]<br><strong>输出:</strong>[1,1,3,2,4,0]<br><strong>解释：</strong><br>1 个单词可以作为 “aboveyz” 的谜底 : “aaaa”<br>1 个单词可以作为 “abrodyz” 的谜底 : “aaaa”<br>3 个单词可以作为 “abslute” 的谜底 : “aaaa”, “asas”, “able”<br>2 个单词可以作为 “absoryz” 的谜底 : “aaaa”, “asas”<br>4 个单词可以作为 “actresz” 的谜底 : “aaaa”, “asas”, “actt”, “access”<br>没有单词可以作为 “gaswxyz” 的谜底，因为列表中的单词都不含字母 ‘g’。</p></blockquote><p><strong>提示：</strong></p><ul><li>1 &lt;= words.length &lt;= 10^5</li><li>4 &lt;= words[i].length &lt;= 50</li><li>1 &lt;= puzzles.length &lt;= 10^4</li><li>puzzles[i].length == 7</li><li>words[i][j], puzzles[i][j] 都是小写英文字母。</li><li>每个 puzzles[i] 所包含的字符都不重复。</li></ul><p>通过次数<code>6,124</code><br>提交次数<code>15,859</code></p><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumOfValidWords</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], puzzles: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        puzzles_list = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> puzzles:</span><br><span class="line">            puzzles_list.append(<span class="built_in">set</span>(p))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(puzzles)):</span><br><span class="line">            t = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">                <span class="keyword">if</span> w[<span class="number">0</span>] == puzzles[i][<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">set</span>(w) | puzzles_list[i] == puzzles_list[i]:</span><br><span class="line">                        t += <span class="number">1</span></span><br><span class="line">            res.append(t)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>铁超时</p><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>对于一个字符串，题目中只需要判断是否出现过，而对于其出现过几次并不关心，因此可以将原来的字符串进行压缩，使之成为26个由0或1组成的数字序列，为了简便表示，可以映射到一个int数字上面。<br>对每一个word，将其进行映射，可能存在多个word映射到同一个int的情况，因此可以使用字典，期中键为被映射的int数字，值为次数，遍历可以得到一个频数字典。</p><h3 id="二进制子集"><a href="#二进制子集" class="headerlink" title="二进制子集"></a>二进制子集</h3><p>为了求出一个puzzle对应得答案得数目，我们需要枚举出puzzle的所有子集，如果存在一个子集与任意一个压缩后的word对应，那么其就是一个答案。因此，如何快速求子集成为关键。</p><ul><li>直观循环<ul><li>枚举长度为1，2，…，7的子集</li></ul></li><li>二进制子集<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_subset</span>(<span class="params">bitmask</span>)</span></span><br><span class="line"><span class="function">    <span class="title">subset</span> = <span class="title">bitmask</span></span></span><br><span class="line"><span class="function">    <span class="title">answer</span> = [<span class="title">bitmask</span>]</span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">subset</span> != 0</span></span><br><span class="line"><span class="function">        <span class="title">subset</span> = (<span class="params">subset - <span class="number">1</span></span>) &amp; <span class="title">bitmask</span></span></span><br><span class="line"><span class="function">        //<span class="title">put</span> <span class="title">subset</span> <span class="title">into</span> <span class="title">the</span> <span class="title">answer</span> <span class="title">list</span></span></span><br><span class="line"><span class="function">    <span class="title">end</span> <span class="title">while</span></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">answer</span></span></span><br></pre></td></tr></table></figure>其中subset是子集字符串压缩后的表示，mask是元字符串压缩后的表示。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumOfValidWords</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], puzzles: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        frequency = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> ch <span class="keyword">in</span> w:</span><br><span class="line">                mask |= <span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">str</span>(<span class="built_in">bin</span>(mask)).count(<span class="string">&#x27;1&#x27;</span>) &lt;= <span class="number">7</span>:</span><br><span class="line">                frequency[mask] += <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> puzzles:</span><br><span class="line">            total = <span class="number">0</span></span><br><span class="line">            mask = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">                mask |= (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(p[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">            subset = mask</span><br><span class="line">            front_ch = (<span class="number">1</span> &lt;&lt; (<span class="built_in">ord</span>(p[<span class="number">0</span>]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)))</span><br><span class="line">            <span class="keyword">while</span> subset:</span><br><span class="line">                s = subset | front_ch</span><br><span class="line">                <span class="keyword">if</span> s <span class="keyword">in</span> frequency:</span><br><span class="line">                    total += frequency[s]</span><br><span class="line">                subset = mask &amp; (subset - <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> front_ch <span class="keyword">in</span> frequency:</span><br><span class="line">                total += frequency[front_ch]</span><br><span class="line">            res.append(total)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>状态压缩</tag>
      
      <tag>子集</tag>
      
      <tag>字符串</tag>
      
      <tag>二进制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>995.K连续位的最小翻转次数</title>
    <link href="/2021/02/18/995-K%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0/"/>
    <url>/2021/02/18/995-K%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="995-K-连续位的最小翻转次数"><a href="#995-K-连续位的最小翻转次数" class="headerlink" title="995. K 连续位的最小翻转次数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数</a></h2><p>在仅包含 <code>0</code> 和 <code>1</code> 的数组 <code>A</code> 中，一次 <code>K</code> 位翻转包括选择一个长度为 <code>K</code> 的（连续）子数组，同时将子数组中的每个 <code>0</code> 更改为 <code>1</code> ，而每个 <code>1</code> 更改为 <code>0</code>。</p><p>返回所需的 <code>K</code> 位翻转的最小次数，以便数组没有值为 <code>0</code> 的元素。如果不可能，返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：A = [1,1,0], K = 2<br>输出：-1<br>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]</p></blockquote><p><strong>提示：</strong></p><blockquote><p>1 &lt;= A.length &lt;= 30000<br>1 &lt;= K &lt;= A.length</p></blockquote><p>通过次数<strong>3,865</strong> 提交次数<strong>8,359</strong></p><h3 id="翻转性质"><a href="#翻转性质" class="headerlink" title="翻转性质"></a>翻转性质</h3><p>对于一个数而言 如果将其翻转 <code>n</code> 次，有以下情况：</p><ul><li>n为偶数，保持原样</li><li>n为奇数，翻转</li></ul><p>但是这样的判断无法直接获取这个数现在到底是 <code>0</code> 还是 <code>1</code>，<strong>可以借助翻转次数和数的和进行判断</strong>， 假设翻转 <code>n</code> 次， 数字原来是 <code>x</code>：</p><ul><li>如果 <code>x + n % 2 == 0</code>, 那么数字 <code>x</code> 在经历 <code>n</code> 次翻转后必定为 <code>0</code>:<ul><li><code>x</code> 为 <code>0</code> 翻转<strong>偶数</strong>次 <code>=&gt;</code> 仍然为 <code>0</code></li><li><code>x</code> 为 <code>1</code> 翻转<strong>奇数</strong>次 <code>=&gt;</code> 仍然为 <code>0</code></li></ul></li><li>如果 <code>x + n % 2 == 1</code>, 那么数字 <code>x</code> 在经历 <code>n</code> 次翻转后必定为 <code>1</code></li></ul><h3 id="记录翻转次数"><a href="#记录翻转次数" class="headerlink" title="记录翻转次数"></a>记录翻转次数</h3><p>由于一次翻转必定要翻转连续的k个数，因此即使相邻的数原来是1，也可能因为这个规则被波及， 因此需要动态的更新每一个位置的信息，很容易想到在翻转之后记录每个位置翻转的次数，但是这就涉及到了遍历子数组，而且显而易见这其中肯定会包含因重叠的翻转区间带来的额外的工作。</p><p>假设有一个数组是这样的</p><blockquote><p>[0,1,0,1,1,0,0]</p></blockquote><p>一次翻转3个数，第一次翻转0，1，0, 为了记录后两个数1，0的翻转情况，无需实际对其进行翻转，而是每次对第一个数进行翻转时，记录前面的数的翻转和，同时对超出区间的第一个数进行标记，将此次翻转的影响截断在区间内，此处的操作就是用一个数组记录，初始化为0，对翻转区间后的第一个数的数组值-1，也就是此处的A[3]，这样就将第一个位置的0翻转通过累加和的形式减去了，这样就不会影响到后面的数。</p><h3 id="差分数组"><a href="#差分数组" class="headerlink" title="差分数组"></a><em>差分数组</em></h3><p>扩展一个差分数组的概念，诸如此类的前后之间有相互影响关系的数组问题，可以利用差分数组最大化的利用好前面已经计算出来的数据。也即，只关注前后两个数之间的关系，通过这种方法累积总体变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minKBitFlips</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        revCnt = <span class="number">0</span> <span class="comment">#记录翻转次数，实时更新，每次遍历到一个位置时其值就是前面所有翻转中影响到了当前位置的翻转次数和</span></span><br><span class="line">        ans = <span class="number">0</span> <span class="comment">#总翻转次数，需要输出</span></span><br><span class="line">        diff = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A) + <span class="number">1</span>)] <span class="comment">#初始化记录数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)): <span class="comment">#按顺序遍历</span></span><br><span class="line">            revCnt += diff[i] <span class="comment">#首先把当前位置的不受影响的减去</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] + revCnt) % <span class="number">2</span> == <span class="number">0</span>: <span class="comment">#如果为0</span></span><br><span class="line">                <span class="keyword">if</span> i + K &gt; <span class="built_in">len</span>(A): <span class="comment">#失败的条件就是最后一次翻转不能恰好完成操作，此处表现为需要翻转的数已经不够了，超出数组长度</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                revCnt += <span class="number">1</span> <span class="comment">#翻转就+1</span></span><br><span class="line">                diff[i + K] -= <span class="number">1</span> <span class="comment">#截断影响</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>翻转</tag>
      
      <tag>差分数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斯月</title>
    <link href="/2021/02/14/%E6%96%AF%E6%9C%88/"/>
    <url>/2021/02/14/%E6%96%AF%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<center><p><strong>斯月</strong></p><p><img src="https://tva1.sinaimg.cn/large/a540b426gy1gnn8wckyqpj22sw1ktb2a.jpg" alt="斯月如初,西升不止"></p><center><p><strong>斯月如初</strong><br><strong>西升不止</strong></p>]]></content>
    
    
    <categories>
      
      <category>文辞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>月</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lc-12.9</title>
    <link href="/2020/12/09/lc-12-9/"/>
    <url>/2020/12/09/lc-12-9/</url>
    
    <content type="html"><![CDATA[<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>经典动态规划，二维表格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">f</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态规划-Plus"><a href="#动态规划-Plus" class="headerlink" title="动态规划 Plus"></a>动态规划 Plus</h4><p>可以将二维表格压缩成一维表格（只保留一行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">            cnt[j] += cnt[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>这也可以作为一个组合问题而存在。<br>从左上角到右下角的过程中，我们需要移动 m+n-2m+n−2 次，其中有 m-1m−1 次向下移动，n-1n−1 次向右移动。因此路径的总数，就等于从 m+n-2m+n−2 次移动中选择 m-1m−1 次向下移动的方案数，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = n, y = <span class="number">1</span>; y &lt; m; ++x, ++y) &#123;</span><br><span class="line">            ans = ans * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>秋雨</title>
    <link href="/2020/11/14/%E7%A7%8B%E9%9B%A8/"/>
    <url>/2020/11/14/%E7%A7%8B%E9%9B%A8/</url>
    
    <content type="html"><![CDATA[<p>烟雨里的重庆还停留在初来乍到时的模样，不经意之间又露出了这番风情，也着实是应景衬情。</p><p>昨天的梦想必是沉重的，穿过脑袋的满满的都是只属于这个秋冬的困倦，那种只有醒来才知道睡下多么美妙的困倦，哪怕是一分钟，也显得满足。此时的人应是空灵的，脑袋里面只有一个困字，没有那么多的时间来穿越春秋，一旦睡下，未来已来。</p><p>依稀听得见外面稍显急促的雨点，确实是记忆里的感觉，不仅仅是几年前，更是刻在基因里的山洞听雨图。还是很亲切的，雨从云里出生，沾染了无尽尘嚣，给迷蒙的秋叶以会心一击，又溜落到行人的伞面，使命的最后一刻就是略显沉闷的一声滴答了。后来，人们只会知道，地面是湿的，因为，下过雨。</p>]]></content>
    
    
    <categories>
      
      <category>文辞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>秋</tag>
      
      <tag>雨</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七夜</title>
    <link href="/2020/11/14/%E4%B8%83%E5%A4%9C/"/>
    <url>/2020/11/14/%E4%B8%83%E5%A4%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="绯梦"><a href="#绯梦" class="headerlink" title="绯梦"></a>绯梦</h2><blockquote><p>醉后不知天在水，满船清梦压星河</p></blockquote><p>旧栏杆倚靠着黑衣服的人</p><p>荡漾几分时间的涟漪</p><p>染黑了遥望星辰的眸</p><p>也只倒印了稀星寥寥</p><p>光与亮，竟是这般对决的姿态</p><p>月色倒是有恃无恐</p><p>那势头，倒也是一直悠闲漫长的</p><p>是什么样的浪漫</p><p>从漆黑中勾勒鹊桥</p><blockquote><p>纤云弄巧、飞星传恨、银汉迢迢暗度</p></blockquote><p>地火蔓延到星河</p><p>浓烟掩盖了孱弱的跃动</p><p>这份柔情、仰望多久才读得懂</p><p>入夜</p><p>夏与秋的缠绵</p><p>燥热的主调，微凉新生</p><p>悱恻的梦落入绯色的月</p><p>编织着朝朝暮暮</p>]]></content>
    
    
    <categories>
      
      <category>诗</category>
      
    </categories>
    
    
    <tags>
      
      <tag>七夕</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二十四点游戏的秘密</title>
    <link href="/2020/08/22/%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%82%B9%E6%B8%B8%E6%88%8F%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2020/08/22/%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%82%B9%E6%B8%B8%E6%88%8F%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-679-24-点游戏Hard"><a href="#Leetcode-679-24-点游戏Hard" class="headerlink" title="Leetcode-679. 24 点游戏Hard"></a><a href="https://leetcode-cn.com/problems/24-game/">Leetcode-679. 24 点游戏</a><code>Hard</code></h2><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) = 24</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</li><li>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。</li><li>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</li></ul><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a><a href="https://leetcode-cn.com/problems/24-game/solution/24-dian-you-xi-by-leetcode-solution/">回溯</a></h3><p>先插进去，计算完成后移除，消除影响</p><h3 id="显示算法"><a href="#显示算法" class="headerlink" title="显示算法"></a>显示算法</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>C/C++</tag>
      
      <tag>二十四点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode周赛202</title>
    <link href="/2020/08/16/leetcode%E5%91%A8%E8%B5%9B202/"/>
    <url>/2020/08/16/leetcode%E5%91%A8%E8%B5%9B202/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode周赛-202"><a href="#LeetCode周赛-202" class="headerlink" title="LeetCode周赛-202"></a><a href="https://leetcode-cn.com/contest/weekly-contest-202">LeetCode周赛-202</a></h2><h3 id="T3-5489-两球之间的磁力"><a href="#T3-5489-两球之间的磁力" class="headerlink" title="T3 5489. 两球之间的磁力"></a>T3 <a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">5489. 两球之间的磁力</a></h3><p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有 <code>n</code> 个空的篮子，第 <code>i</code> 个篮子的位置在 <code>position[i]</code> Morty 想把 <code>m</code> 个球放到这些篮子里，使得任意两球间 <strong>最小磁力</strong> 最大。已知两个球如果分别位于 <code>x</code> 和 <code>y</code> ，那么它们之间的磁力为 <code>|x - y|</code> 。给你一个整数数组 <code>position</code> 和一个整数 <code>m</code> ，请你返回最大化的最小磁力。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/16/q3v1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [1,2,3,4,7], m = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [5,4,3,2,1,1000000000], m = 2</span><br><span class="line">输出：999999999</span><br><span class="line">解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == position.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= position[i] &lt;= 10^9</code></li><li>所有 <code>position</code> 中的整数 <strong>互不相同</strong> 。</li><li><code>2 &lt;= m &lt;= position.length</code></li></ul><h4 id="算法：二分"><a href="#算法：二分" class="headerlink" title="算法：二分"></a>算法：二分</h4><p>最小：相邻槽位的最小值</p><p>最大：总长度/分成的间隔数（球数-1）</p><p>检查：所需球数 &gt; 规定的球数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;pos;</span><br><span class="line">    <span class="keyword">int</span> ballCnt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> dis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = pos[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p - prev &gt;= dis)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                prev = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//early stop</span></span><br><span class="line">            <span class="comment">//todo</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= ballCnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; position, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(position.<span class="built_in">begin</span>(), position.<span class="built_in">end</span>());</span><br><span class="line">        pos = position;</span><br><span class="line">        ballCnt = m;</span><br><span class="line">        <span class="keyword">int</span> maxDis = (position.<span class="built_in">back</span>() - position[<span class="number">0</span>]) / (m<span class="number">-1</span>), minDis = maxDis;</span><br><span class="line">        <span class="keyword">int</span> last = -maxDis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:position)&#123;</span><br><span class="line">            minDis = <span class="built_in">min</span>(minDis, p - last);</span><br><span class="line">            last = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = minDis, r = maxDis, mid, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            mid = l - (l - r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(l)) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><strong>时间：</strong>遍历：$O(n)$，二分$O(log_2n)$，故$O(log_2n)$</p><p><strong>空间：</strong>$O(n)$</p><h3 id="T4-5490-吃掉-N-个橘子的最少天数hard"><a href="#T4-5490-吃掉-N-个橘子的最少天数hard" class="headerlink" title="T4 5490. 吃掉 N 个橘子的最少天数hard"></a>T4 <a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges/">5490. 吃掉 N 个橘子的最少天数</a><code>hard</code></h3><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p><ul><li>吃掉一个橘子。</li><li>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li><li>如果剩余橘子数 <code>n</code> 能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li></ul><p>每天你只能从以上 3 种方案中选择一种方案。</p><p>请你返回吃掉所有 <code>n</code> 个橘子的最少天数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：你总共有 10 个橘子。</span><br><span class="line">第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。</span><br><span class="line">第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）</span><br><span class="line">第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。</span><br><span class="line">第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。</span><br><span class="line">你需要至少 4 天吃掉 10 个橘子。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：3</span><br><span class="line">解释：你总共有 6 个橘子。</span><br><span class="line">第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）</span><br><span class="line">第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）</span><br><span class="line">第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。</span><br><span class="line">你至少需要 3 天吃掉 6 个橘子。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 56</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2*10^9</code></li></ul><h4 id="算法：BFS-哈希表"><a href="#算法：BFS-哈希表" class="headerlink" title="算法：BFS+哈希表"></a>算法：BFS+哈希表</h4><p>每次多种路径，我们自然会想到从上而下的构建一颗树<img src="https://tva4.sinaimg.cn/large/a540b426ly1ghsx2dws4cj20py0f7glm.jpg" alt="lc-wk202-t4-tree"></p><p>本题的关键在于这样的一个事实，我们构建的树包括有太多的重复计算，需要对其进行剪枝处理。不难想到，<strong>当我们以BFS的方式层次地形成这颗树地时候，如果树地节点的数值在之前形成过，那么一定有之前的算法处理步骤要比当前的步骤节省天数</strong>，那么当前的这个就可以不算，也就是剪枝。具体表现为，不将当前的值加入到下一轮的迭代之中，这样可以大幅的减少处理的数量。</p><p>为了记录某个数之前是否出现过，最佳方法自然是使用哈希，也就是用一个哈希表记录运算的历史</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; isReached;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                <span class="keyword">int</span> orange = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(orange == <span class="number">0</span>) <span class="keyword">return</span> days;</span><br><span class="line">                <span class="keyword">if</span>(orange % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; isReached.<span class="built_in">count</span>(orange / <span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(orange / <span class="number">3</span>);</span><br><span class="line">                    isReached.<span class="built_in">insert</span>(orange / <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(orange % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; isReached.<span class="built_in">count</span>(orange / <span class="number">2</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(orange / <span class="number">2</span>);</span><br><span class="line">                    isReached.<span class="built_in">insert</span>(orange / <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isReached.<span class="built_in">count</span>(orange - <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(orange - <span class="number">1</span>);</span><br><span class="line">                    isReached.<span class="built_in">insert</span>(orange - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            days++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>关于时间复杂度，由于数据的不确定性对运算的流程影响比较大，难以估计</p><p>空间复杂度，主要的空间使用为哈希表和队列，这些也和过程有关，也不好说</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>二分</tag>
      
      <tag>BFS</tag>
      
      <tag>剪枝</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode_Week_7.12</title>
    <link href="/2020/07/13/LeetCode-Week-7-12/"/>
    <url>/2020/07/13/LeetCode-Week-7-12/</url>
    
    <content type="html"><![CDATA[<h2 id="5460-好数对的数目"><a href="#5460-好数对的数目" class="headerlink" title="5460.好数对的数目"></a>5460.好数对的数目</h2><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code> 满足 <code>nums[i]</code> == <code>nums[j]</code> 且 <code>i</code> &lt; <code>j</code> ，就可以认为这是一组 <strong>好数对</strong> 。</p><p>返回好数对的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有 <span class="number">4</span> 组好数对，分别是 (<span class="number">0</span>,<span class="number">3</span>), (<span class="number">0</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">2</span>,<span class="number">5</span>) ，下标从 <span class="number">0</span> 开始</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1]</span><br><span class="line">输出：6</span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h3><p>找数组中重复的元素，存储重复次数和重复种类，可以考虑用Map，然后根据组合公式<br>$$<br>C^m_n=\frac{n!}{m!(n-m)!}<br>$$<br>后来发现就是狗屁，直接计算重复的累加和就行了，即<br>$$<br>\sum_{m=1}^k\sum_{i=1}^{p}<br>$$</p><h3 id="代码🐎"><a href="#代码🐎" class="headerlink" title="代码🐎"></a>代码🐎</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getARes</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">            res+=t--;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m = unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">            m[n]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> kv:m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(kv.second&gt;<span class="number">1</span>)</span><br><span class="line">                res+=<span class="built_in">getARes</span>(kv.second<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="仅含-1-的子串数"><a href="#仅含-1-的子串数" class="headerlink" title="仅含 1 的子串数"></a>仅含 1 的子串数</h2><p>给你一个二进制字符串 <code>s</code>（仅由 ‘0’ 和 ‘1’ 组成的字符串）。</p><p>返回所有字符都为 1 的子字符串的数目。</p><p>由于答案可能很大，请你将它对 10^9 + 7 取模后返回。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0110111&quot;</span><br><span class="line">输出：9</span><br><span class="line">解释：共有 9 个子字符串仅由 &#x27;1&#x27; 组成</span><br><span class="line">&quot;1&quot; -&gt; 5 次</span><br><span class="line">&quot;11&quot; -&gt; 3 次</span><br><span class="line">&quot;111&quot; -&gt; 1 次</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;101&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：子字符串 &quot;1&quot; 在 s 中共出现 2 次</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;111111&quot;</span><br><span class="line">输出：21</span><br><span class="line">解释：每个子字符串都仅由 &#x27;1&#x27; 组成</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;000&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s[i] == &#39;0&#39;</code> 或 <code>s[i] == &#39;1&#39;</code></li><li><code>1 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="初步思路-1"><a href="#初步思路-1" class="headerlink" title="初步思路"></a>初步思路</h3><p>和上题类似，遍历字符串，计算每一个全为1的字串的贡献<br>$$<br>res=\sum_{k=1}^{all}\sum_{i=1}^{k}<br>$$</p><h3 id="代码🐎-1"><a href="#代码🐎-1" class="headerlink" title="代码🐎"></a>代码🐎</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subRes</span><span class="params">(<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l) res=(res+l--)%<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                count+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    res+=<span class="built_in">subRes</span>(count);</span><br><span class="line">                    count=<span class="number">0</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count) res+=<span class="built_in">subRes</span>(count);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
      <tag>周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-每日一题-7月编</title>
    <link href="/2020/07/13/LeetCode-7-13/"/>
    <url>/2020/07/13/LeetCode-7-13/</url>
    
    <content type="html"><![CDATA[<h3 id="718-最长重复子数组中等"><a href="#718-最长重复子数组中等" class="headerlink" title="718. 最长重复子数组中等"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a><code>中等</code></h3><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="attr">A</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="attr">B</span>: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">长度最长的公共子数组是 [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= len(A), len(B) &lt;= 1000</code></li><li><code>0 &lt;= A[i], B[i] &lt; 100</code></li></ul><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span> .. A.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span> .. B.length - <span class="number">1</span>]</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (A[i+k] == B[j+k]) do   <span class="comment"># and i+k &lt; A.length etc.</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        end <span class="keyword">while</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, k)</span><br><span class="line">    end <span class="keyword">for</span></span><br><span class="line">end <span class="keyword">for</span></span><br></pre></td></tr></table></figure><p>$O(n^3)$的时间复杂度，不行</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li><strong>状态转移方程</strong></li></ul><p>设<code>dp[i][j]</code>表示<code>A</code>的前<code>i</code>个元素和<code>B</code>的前<code>j</code>个元素的最长公共后缀长度，那么<br>$$<br>\begin{equation}<br>dp[i][j]=\left{<br>\begin{aligned}<br>&amp;dp[i-1][j-1] + 1 &amp; &amp; {A[i] = B[j]}\<br>&amp;dp[i-1][j-1] &amp; &amp; {A[i] \not = B[j]}\<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$</p><ul><li><p><strong>🐴</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l1 = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l2 = B.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(l1+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(l2+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; l2; ++j)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = A[i] == B[j] ? dp[i][j] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>注意此处也可以使用最长公共前缀，意思一样，但是一定要注意是<strong>缀</strong>，也就是说最后一个/第一个一定要相同，否则就是0</p></li></ul><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul><li><p><img src="https://pic.leetcode-cn.com/9ed48b9b51214a8bafffcad17356d438b4c969b4999623247278d23f1e43977f-%E9%94%99%E5%BC%80%E6%AF%94%E8%BE%83.gif" alt="滑动窗口"></p></li><li><p>思想就是逐个对齐，然后在当前的对齐条件下寻找最大的</p></li><li><p>代码</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l1 = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l2 = B.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1+l2<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">max</span>(<span class="number">0</span>,i-l2+<span class="number">1</span>);j&lt;=<span class="built_in">min</span>(l1<span class="number">-1</span>,i);++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j] == B[l2 + j - i - <span class="number">1</span>]) ++tmp;</span><br><span class="line">                <span class="keyword">else</span> tmp = <span class="number">0</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(tmp,res);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="350-两个数组的交集-II简单"><a href="#350-两个数组的交集-II简单" class="headerlink" title="350. 两个数组的交集 II简单"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a><code>简单</code></h3><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶:</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li><li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法:"></a>暴力解法:</h4><p>就是暴力，拔说了</p><h4 id="排序比较"><a href="#排序比较" class="headerlink" title="排序比较:"></a>排序比较:</h4><p><strong>算法：</strong><br>    1.    先排序两个数组<br>        2.    确定其中长的为基准数组，短的为移动数组<br>            3.    依次遍历短的，找到共存的</p><p><strong>代码V1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> l1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span>(l1&lt;l2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l1;++i)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pos&lt;l2 &amp;&amp; nums2[pos]&lt;=nums1[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums1[i]==nums2[pos++])&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(nums1[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l2;++i)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pos &lt; l1 &amp;&amp; nums1[pos]&lt;=nums2[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums2[i]==nums1[pos++])&#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>    1.    注意数组的边界问题<br>    2.    遇到诸如此类的问题最好不要这样遍历，可以考虑</p><p><strong>代🐎2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> l1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(f&lt;l1 &amp;&amp; s&lt;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[f]&lt;nums2[s])</span><br><span class="line">                ++f;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums1[f]&gt;nums2[s])</span><br><span class="line">                ++s;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums1[f]);</span><br><span class="line">                ++f;</span><br><span class="line">                ++s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>定义多个变量如<code>int a,b=0;</code>时，需要对每个变量都分别赋初值才能全部都有初值。</li></ol><h4 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h4><p><strong>算法：</strong></p><p>将其中哈希化，然后遍历另一个表，看重合的。</p><p><strong>代🐎：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:nums1)&#123;</span><br><span class="line">            m[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums2.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[nums2[i]]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums2[i]);</span><br><span class="line">                m[nums2[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="120-三角形最小路径和中等"><a href="#120-三角形最小路径和中等" class="headerlink" title="120. 三角形最小路径和中等"></a><a href="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和</a><code>中等</code></h3><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p><strong>相邻的结点</strong> 在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。</p><p>例如，给定三角形：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><p><strong>说明：</strong></p><p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p><h4 id="树式递归"><a href="#树式递归" class="headerlink" title="树式递归"></a>树式递归</h4><p><strong>算法：</strong></p><p>深入到每一个底层去计算，得到最小值</p><p><strong>代🐎:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; tg;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">100000000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reFind</span><span class="params">(<span class="keyword">int</span> curVal,<span class="keyword">int</span> level,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level==tg.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = curVal+tg[level][pos];</span><br><span class="line">        <span class="keyword">if</span>(level==tg.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&lt;res) res = tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(tmp&gt;=res) return;</span></span><br><span class="line">        <span class="built_in">reFind</span>(tmp,level+<span class="number">1</span>,pos);</span><br><span class="line">        <span class="built_in">reFind</span>(tmp,level+<span class="number">1</span>,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        tg = triangle;</span><br><span class="line">        <span class="built_in">reFind</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>超时！！！</p><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>算法：</strong></p><p>如果将每一行的左端对齐，那么会形成一个等腰直角三角形，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2]</span><br><span class="line">[3,4]</span><br><span class="line">[6,5,7]</span><br><span class="line">[4,1,8,3]</span><br></pre></td></tr></table></figure><p>如果以<code>f[i][j]</code>表示从<code>c[i][j]</code>到底部的最小路径，那么一定会有<br>$$<br>f[i][j]=min(f[i-1][j],f[i-1][j+1])+c[i][j]<br>$$<br>其中<code>f[i][j]</code>中的<code>i</code>是从下往上生长的，则求的是<code>f[triangle.size()-1][0]</code></p><p><strong>代🐎：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxHei = triangle.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = triangle[maxHei<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxHei;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = maxHei - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=pos;++j)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j+<span class="number">1</span>])+triangle[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>这是从下往上的版本，不需要考虑边界问题，如果是从上往下，就需要考虑边界了。</p><h3 id="96-不同的二叉搜索树中等"><a href="#96-不同的二叉搜索树中等" class="headerlink" title="96. 不同的二叉搜索树中等"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a><code>中等</code></h3><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n = 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line">   1         3     3      2      1</span><br><span class="line"><span class="code">    \       /     /      / \      \</span></span><br><span class="line"><span class="code">     3     2     1      1   3      2</span></span><br><span class="line"><span class="code">    /     /       \                 \</span></span><br><span class="line"><span class="code">   2     1         2                 3</span></span><br></pre></td></tr></table></figure><h4 id="何为二叉搜索树？"><a href="#何为二叉搜索树？" class="headerlink" title="何为二叉搜索树？"></a>何为二叉搜索树？</h4><p>简单来讲，就是左边比父节点小，右边比父节点大</p><h4 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h4><p>很直观，就是分成<code>左边×右边</code>，左右两边都是子问题。<br>$$<br>G(n)=\sum_{i=1}^nF(i,n)\<br>F(i,n)=G(i-1)\times G(n-i)\<br>G(n)=\sum_{i=1}^nG(n-1)\times G(n-i)<br>$$<br><strong>🐴</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dp = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;++j)&#123;</span><br><span class="line">                dp[i]+=dp[j<span class="number">-1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="785-判断二分图中等"><a href="#785-判断二分图中等" class="headerlink" title="785. 判断二分图中等"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a><code>中等</code></h3><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点<code>i</code>相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: [[<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line"><span class="number">0</span>---<span class="number">-1</span></span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line"><span class="number">3</span>---<span class="number">-2</span></span><br><span class="line">我们可以将节点分成两组: &#123;<span class="number">0</span>, <span class="number">2</span>&#125; 和 &#123;<span class="number">1</span>, <span class="number">3</span>&#125;。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>], [<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line"><span class="number">0</span>---<span class="number">-1</span></span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line"><span class="number">3</span>---<span class="number">-2</span></span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li><li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li><li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li><li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li></ul><h4 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h4><p>对于处于同一边的两端的节点，显然它们不能在同一个集合里面，因此可以使用染色法，同一个节点集合的用同一种颜色，不同节点集合之间用不同的颜色。这里涉及到图的遍历问题，有DFS和BFS两种，都是可以使用的。</p><p><strong>DFS算法</strong></p><ul><li><p><strong>输入：</strong>节点v，颜色c，图g</p></li><li><p><strong>函数：</strong>dfs</p></li><li><p><strong>过程</strong></p><ul><li><p>将节点<code>v</code>的颜色设为<code>c</code>，并根据c生成c的相邻节点的颜色<code>cN</code></p></li><li><p>遍历<code>v</code>的相邻节点，如果存在未染色的节点，就递归调用<code>dfs</code>，否则判断颜色是否为<code>cN</code>，如果存在颜色不为<code>cN</code>的节点，则函数返回<code>False</code>，否则返回<code>dfs</code>的返回结果</p></li></ul></li><li><p><strong>代🐴</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; color;</span><br><span class="line">    <span class="keyword">bool</span> vaild;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        color[node]=c;</span><br><span class="line">        <span class="keyword">int</span> cN = (c==<span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : g[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[n]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(cN,n);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[n]!=cN)&#123;</span><br><span class="line">                vaild = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!vaild)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        g = graph;</span><br><span class="line">        color = vector&lt;<span class="keyword">int</span>&gt;(graph.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        vaild = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">dfs</span>(<span class="number">1</span>,i);</span><br><span class="line">        <span class="keyword">return</span> vaild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>BFS算法</strong></p><ul><li><p><strong>输入</strong>：节点<code>v</code>,颜色<code>c</code></p></li><li><p><strong>输出</strong>：是否能够染色</p></li><li><p><strong>过程</strong>：函数bfs</p><ul><li>令<code>v</code>的颜色为<code>c</code>，并计算得到相邻节点的颜色<code>cN</code></li><li>对<code>v</code>的所有相邻节点，判断是否已经染色，没有就染上色，有就判断是否冲突，如果冲突直接返回<code>False</code>，否则依次进入队列</li><li>对栈中的元素一次执行<code>bfs</code></li></ul></li><li><p><strong>代🐎</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; color;</span><br><span class="line">    <span class="keyword">bool</span> vaild;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> c,<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(node);</span><br><span class="line">        color[node] = c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cN = c;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = s.<span class="built_in">front</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            cN = (color[curr] == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> n:g[curr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(color[n]==<span class="number">0</span>)&#123;</span><br><span class="line">                    color[n]=cN;</span><br><span class="line">                    s.<span class="built_in">push</span>(n);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[n]!=cN)&#123;</span><br><span class="line">                    vaild = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        g = graph;</span><br><span class="line">        color = vector&lt;<span class="keyword">int</span>&gt;(graph.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        vaild = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();++i)</span><br><span class="line">            <span class="keyword">if</span>(color[i]==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">bfs</span>(<span class="number">1</span>,i);</span><br><span class="line">        <span class="keyword">return</span> vaild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong></p><ul><li>本题DFS比BFS快，原因待查，因为两者的实践复杂度都是<code>O(M+N)</code></li><li>BFS比DFS难写一些</li></ul><h3 id="35-搜索插入位置简单"><a href="#35-搜索插入位置简单" class="headerlink" title="35. 搜索插入位置简单"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a><code>简单</code></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>通过次数194,591    提交次数420,682 </p><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p>经典二分，注意边界，二分问题需要一边出现渐进式的增长，一般选取<code>l=mid+1</code></p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">                r = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l]&gt;=target)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;nums.<span class="built_in">back</span>()) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Note</strong></p><p>第二个方法太玄学了，添加在<code>while</code>内的<code>cout</code>不输出</p><h3 id="410-分割数组的最大值-困难"><a href="#410-分割数组的最大值-困难" class="headerlink" title="410. 分割数组的最大值 困难"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> <code>困难</code></h3><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 <em>m</em> 个非空的连续子数组。设计一个算法使得这 <em>m</em> 个子数组各自和的最大值最小。</p><p><strong>注意:</strong><br>数组长度 <em>n</em> 满足以下条件:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><p>通过次数11,569    提交次数24,173</p><h4 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/solution/fen-ge-shu-zu-de-zui-da-zhi-by-leetcode-solution/">动态规划</a></h4><h4 id="二分-1"><a href="#二分-1" class="headerlink" title="二分"></a>二分</h4><ul><li><p>不难求出最小的最大值的取值范围是<code>[max(nums),sum(nums)]</code>，有了范围，就可以在范围内进行二分搜索，不断计算得到一个最小值。</p></li><li><p>算法：</p><ul><li>求出最大值<code>maxVal</code>和最小值<code>minVal</code></li><li>循环执行，直到<code>minVal&gt;=maxVal</code></li><li>计算中值<code>midVal</code>，并且计算能够分段的段数<code>cnt</code></li><li>比较<code>cnt</code>和<code>m</code>的大小关系<ul><li>如果<code>cnt&lt;m</code>，那么说明分段分少了，好可以再分多一些段，也就是最大值还可以再小一些，即<code>minVal = midVal + 1</code></li><li>否则，<code>cnt&gt;=m</code>，说明分段分多了，也就是最大值小了，这种情况下让分的值小一些，令<code>maxVal  =  midVal</code></li></ul></li><li>输出<code>minVal</code></li></ul></li><li><p>代🐎：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxVal = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">int</span> minVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> midVal;</span><br><span class="line">        <span class="keyword">while</span>(minVal &lt; maxVal)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            midVal = minVal + (maxVal - minVal) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;minVal&lt;&lt;&quot; &quot;&lt;&lt;midVal&lt;&lt;&quot; &quot;&lt;&lt;maxVal&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">               tmp += nums[i];</span><br><span class="line">               <span class="keyword">if</span>(tmp &gt; midVal)&#123;</span><br><span class="line">                   tmp = nums[i];</span><br><span class="line">                   ++cnt;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; m) minVal = midVal + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> maxVal = midVal;</span><br><span class="line">            <span class="comment">// else break;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="329-矩阵中的最长递增路径困难"><a href="#329-矩阵中的最长递增路径困难" class="headerlink" title="329. 矩阵中的最长递增路径困难"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a><code>困难</code></h3><p>给定一个整数矩阵，找出最长递增路径的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><h4 id="动态规划-3"><a href="#动态规划-3" class="headerlink" title="动态规划"></a>动态规划</h4><ul><li><p>状态转移方程<br>  $$<br>  f[i][j]=max{(matrix[i][j] &gt; matrix[i-1][j]) \cdot f[i-1][j],\(matrix[i][j] &gt; matrix[i][j-1]) \cdot f[i][j-1],\(matrix[i][j] &gt; matrix[i+1][j]) \cdot f[i+1][j],\(matrix[i][j] &gt; matrix[i][j+1]) \cdot f[i][j+1]}<br>  $$<br>  其中<code>f[i][j]</code>表示以<code>matrix[i][j]</code>结尾的路径长度</p></li><li><p>代码</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reFind</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; matrix[i][j]&gt;matrix[i<span class="number">-1</span>][j]) len = <span class="built_in">max</span>(len,<span class="built_in">reFind</span>(matrix,i<span class="number">-1</span>,j));</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &lt; matrix.<span class="built_in">size</span>() &amp;&amp; matrix[i][j]&gt;matrix[i+<span class="number">1</span>][j]) len = <span class="built_in">max</span>(len,<span class="built_in">reFind</span>(matrix,i+<span class="number">1</span>,j));</span><br><span class="line">        <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; matrix[i][j] &gt; matrix[i][j<span class="number">-1</span>]) len = <span class="built_in">max</span>(len,<span class="built_in">reFind</span>(matrix,i,j<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; matrix[i][j]&gt;matrix[i][j+<span class="number">1</span>]) len = <span class="built_in">max</span>(len,<span class="built_in">reFind</span>(matrix,i,j+<span class="number">1</span>));</span><br><span class="line">        ++len;</span><br><span class="line">        dp[i][j] = len;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(matrix.<span class="built_in">size</span>(),vector&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen,<span class="built_in">reFind</span>(matrix,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul><li><p>算法概述</p><p>  首先要有一个有向无环图G，然后对图中的每个节点，找到入度为0的节点，删除和它关联的所有边，更新入度信息，输出顺序，就可以得到一个输出顺序</p></li><li><p>本题的应用</p><p>  归根结底，本题是计算拓扑中的层级</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a((1)) --&gt; c((3))</span><br><span class="line">e((0)) --&gt; a((1))</span><br><span class="line">b((2)) --&gt; c((3))</span><br><span class="line">c((3)) --&gt; d((4))</span><br></pre></td></tr></table></figure><p>  这种情况下，就是4，也就是最长的那条，但实际上可以分为4个层次。</p></li><li><p>代码</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> outdegrees = vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; (rows, vector &lt;<span class="keyword">int</span>&gt; (columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = i + dirs[k][<span class="number">0</span>], newColumn = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        ++outdegrees[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue &lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cell = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> row = cell.first, column = cell.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = row + dirs[k][<span class="number">0</span>], newColumn = column + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) &#123;</span><br><span class="line">                        --outdegrees[newRow][newColumn];</span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[newRow][newColumn] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123;newRow, newColumn&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  * 此处代码源自<a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/solution/ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing-by-le-2/">【力扣题解】</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天气之子</title>
    <link href="/2020/05/12/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/"/>
    <url>/2020/05/12/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="初夏，新风"><a href="#初夏，新风" class="headerlink" title="初夏，新风"></a>初夏，新风</h3><blockquote><p>没有燥热，没有暴雨，新来的日子数着天过着，我往复的看着，没有丝毫犹豫，却张张惶惶。<br><img src="https://tvax1.sinaimg.cn/large/a540b426gy1gepzptc08oj23402bsx6q.jpg" alt="img"></p></blockquote><p>我们算不算《后浪》，我是不是《后浪》，我从不曾思考过这个问题，似乎显然我已经将自己置身于事外了。但是其实是一种痴缠的无理，算便是算，不算便是不算，一张弃权票显得那么真实又让我低语、无言。</p><p>东京几时下雨，几时放晴，会不会被淹没，人们往哪里去，站在黄昏的高楼看夕阳时，我会不会想到这些呢？似乎我不太在意那个最刺眼的，更加青睐层次分明，有着明显过度的朦胧，无论冷暖。或许还是更偏心于蓝色的冷漠，但其实是蓄意渲染的悲凉，用这些来浸润一种似乎是从灵魂中冒出来的支撑、慰藉的凄寒。</p><p>必须是抽离的时候了，再厚的茧也终要破裂，除非死去。尽管人终究是要这般的，可是也无妨我们让焰火再绚烂一些，视网膜上残影，或许还能带来一段不一般的幻想。然而仔细说来，我又不是因着这些才以碌碌的姿态去苟存的，这些种种复杂、简单、交错、单一。</p><h3 id="东京，暴雨"><a href="#东京，暴雨" class="headerlink" title="东京，暴雨"></a>东京，暴雨</h3><blockquote><p>是否会有一场这样的雨，因你而起，因我难终。<br><img src="https://tva4.sinaimg.cn/large/a540b426gy1geq0sfd3ilj21bs0ovkjl.jpg" alt="东京、雨"></p></blockquote><p>雨还在下，不过不在我的天空，风还在吹，吹到了我的天台，惊扰了蜷在杂物里的幼猫。 享受雨天的静僻，那种被阴暗覆没，世界将倾倒，唯我安宁的感觉，刺激着隐匿在人类基因里的洞穴记忆。一团火载一群人，映半盏旧梦。难以想起当雨一直下，阴郁替代光亮的感受，但至少这个春天我们体验了一次“东京”之“雨”。</p><p>或许可以升华到一个烂俗的高度，但是现实就是学校里的钟铃比手机里无数个闹钟更加震撼，路上比床上更舒心，坦荡。</p><p>如果帆高不知道、那梵高会不会知道，但我知道，璠高一定知道。<br><img src="https://tvax2.sinaimg.cn/large/a540b426gy1geq23ddbfbj21hc0u07wh.jpg" alt="阳菜"></p><h3 id="北斗，疏星"><a href="#北斗，疏星" class="headerlink" title="北斗，疏星"></a>北斗，疏星</h3><blockquote><p>天旋地转，当时空交错，你是否还知道，何处是天枢<br><img src="https://tva1.sinaimg.cn/large/a540b426gy1geq286nuwfj21110kudh6.jpg" alt="北斗、星轨"></p></blockquote><p>似乎想了很久，但是一直拖延，直到没了热情，就死在半路。所幸能够寻得闲情，终以夙愿。它们旋转到屋檐后面，无谓的躲藏？我们向西行进，原地踏步，以银河之眼，亦是渺茫，便舍弃自作多情。</p><p>星辰、宇宙、人与世界。</p>]]></content>
    
    
    <categories>
      
      <category>电影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动漫 新海诚 青春</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020暑期实习面经--腾讯</title>
    <link href="/2020/04/28/2020%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F-%E8%85%BE%E8%AE%AF/"/>
    <url>/2020/04/28/2020%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F-%E8%85%BE%E8%AE%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>腾讯虽然问的问题虽然也不是那么刁钻，中规中矩，但总觉得不是针对实习生的。不过面试官素质还是在的，尽管面的不怎么顺。本来面过了就不想去回首这些东西的，但是为了不白走这一趟，还是顺手记录一下。</p><h3 id="腾讯PCG不知名部门"><a href="#腾讯PCG不知名部门" class="headerlink" title="腾讯PCG不知名部门"></a>腾讯PCG不知名部门</h3><h4 id="相关信息"><a href="#相关信息" class="headerlink" title="相关信息"></a>相关信息</h4><p>目标岗位：移动客户端开发<br>面试平台：腾讯会议视频面试（单方面视频）<br>技术栈：C++<br>时间：4.11</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>其实在面试的前一天就约了一场，但是面试时间从上午10点，拖到下午两点，再拖到下午四点，然后又从四点拖到四点二十，再到五点，再换个手下的人，又说不熟悉简历拖到五点三十，面了四十分钟就草草收场，估计也是不怎么专业，第二天leader亲自面试一场，反正就是迷的一批。说起来，这还算的上是个二面。</p><p>一上来，确认身份，没有废话，直接开问。（以下问题排名随机）<br>问题不给任何反馈，看你没话说了就下一个，不露脸，看不到表情。</p><p><strong>基础知识</strong></p><ul><li>指针和引用<br>太宽泛，不好讲</li><li>sizeof一个指针和一个引用<ul><li><a href="http://www.blogjava.net/majianan/archive/2006/08/20/64664.html">关于 sizeof() 的一些思考</a></li><li>sizeof(指针)：固定大小32bit系统-4，64bit-8，因为指针存储的是地址，一个64bit系统的地址空间需要64位/8Byte的空间来存</li><li>sizeof(数组)：数组总共大小</li><li>sizeof(string)：固定，具体和编译器有关</li><li>sizeof(引用)：sizeof操作符应用在引用类型上的时候，返回的是包含被引用对象所需的内存长度（即被引用对象的大小）</li><li>sizeof(结构体)：地址对齐后的大小<ul><li>字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则：</li></ul><ol><li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量都是当前成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；</li><li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</li></ol></li><li>sizeof(类)：非static数据成员变量+虚函数指针+对齐；无论多少个虚函数，都只有一个指向虚函数表的指针(4字节)</li><li>sizeof(联合体)：最长成员的大小对齐</li></ul></li><li>sizeof和什么有关<ul><li>编译器</li><li>系统位数</li></ul></li><li>vector的插入和删除的复杂度<ul><li>push_back,pop_back O(1)</li><li>insert,erase O(n)</li></ul></li><li>迭代器失效是怎么回事，怎么避免<ul><li>序列式（vector，deque）<ul><li>插入，插入元素以及以后的迭代器失效</li><li>删除，删除元素以及以后的迭代器失效</li><li>扩容：全部失效</li></ul></li><li>关联式（list，map，set）<ul><li>插入：不影响其它</li><li>删除：不影响其它</li></ul></li></ul></li><li>TCP为什么要四次挥手<ul><li>保证稳定传输，需要等待数据传送完成</li></ul></li><li>C++常引用的作用/意义<ul><li>防止修改被引用对象的值</li></ul></li><li>？如何在函数中修改参数的值<ul><li>传引用/指针</li></ul></li><li>信号量和锁的区别，应用场景<ul><li>锁（互斥锁，自旋锁，读写锁）<ul><li>线程之间，只有两种状态，要么能访问，要么不能。用来互斥</li></ul></li><li>信号量<ul><li>多种状态，可以用来互斥，也可以用来同步。比如有限资源的同步。</li></ul></li></ul></li><li>map是怎么实现的，查找复杂度<ul><li>红黑树，log（n）</li></ul></li><li>红黑树简单介绍<ul><li>根是黑的</li><li>没有两个相邻的红色节点</li><li>从根到任何根节点的黑色节点数量相同</li></ul></li><li>HTTPS的流程</li></ul><ol><li><p>客户端请求建立SSL连接，并将自己支持的一套加密规则发送给网站。</p></li><li><p>   网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息</p></li><li><p>获得网站证书之后浏览器要做以下工作：</p><ul><li><p>验证证书的合法性</p></li><li><p>如果证书受信任，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</p></li><li><p> 使用约定好的HASH计算握手消息，</p></li><li><p> 使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p></li></ul></li><li><p>网站接收浏览器发来的数据之后要做以下的操作：</p><ul><li><p> 使用自己的私钥将信息解密取出密码</p></li><li><p> 使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</p></li><li><p> 使用密码加密一段握手消息，发送给浏览器</p></li></ul></li><li><p>   浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手结束。</p></li><li><p>   使用随机密码和对称加密算法对传输的数据加密，传输。</p></li></ol><ul><li>对称加密和非对称加密的区别，应用场景</li></ul><ol><li><p>   非对称加密算法：RSA，DSA/DSS，用于在握手过程中加密生成的密码。</p></li><li><p>   对称加密算法：AES，RC4，3DES，用于对真正传输的数据进行加密。</p></li><li><p>   HASH算法：MD5，SHA1，SHA256，验证数据的完整性。</p></li></ol><ul><li>   HTTP与HTTPS的区别：</li></ul><ol start="5"><li><p>   https协议需要申请证书。</p></li><li><p>   http是超文本传输协议，明文传输；https使用的是具有安全性的SSL加密传输协议。</p></li><li><p>   http连接简单无状态；https由SSL+HTTP协议构件的可进行加密传输、身份验证的网络协议</p></li></ol><p><strong>项目相关</strong></p><ul><li>一个API请求时间长，怎么排查</li><li>用过的一些辅助开发工具</li></ul><p><strong>算法</strong></p><ul><li>两个链表找交点<ul><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">相交链表</a></li><li>双指针法</li></ul></li><li>k个不同长度的木材截成相同长度的小段n段，求每段的最大长度，精确到小数点后两位。<ul><li>二分</li><li>首先求出最大长度（总长度/段数），然后判断是否满足条件，不满足就二分，直到满足精度或者停止</li></ul></li></ul><p><strong>反问</strong></p><ul><li>有什么建议</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>应该是在第二天就灰了，随后被下文的企业微信部捞起来鞭尸，知识密度比较大，虽然感觉答得不算差，但是还是拔太行。</p><h3 id="腾讯WXG企业微信部"><a href="#腾讯WXG企业微信部" class="headerlink" title="腾讯WXG企业微信部"></a>腾讯WXG企业微信部</h3><h4 id="相关信息-1"><a href="#相关信息-1" class="headerlink" title="相关信息"></a>相关信息</h4><p>目标岗位：客户端开发<br>面试平台：牛客网（双向视频）<br>技术栈：C++<br>时间：4.13</p><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><p>头天发短信预约时间，约在第二天上午，准时开始，面试官挺严肃。</p><p><strong>基础知识</strong></p><ul><li><p>C++ const介绍<br><a href="https://www.cnblogs.com/jiabei521/p/3335676.html">C++中const关键字的使用方法，烦透了一遍一遍的搜，总结一下，加深印象！！！</a></p></li><li><p>四种智能指针</p><ul><li>使用智能指针可以很大程度上的避免频繁的new/malloc delete/free的问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。</li><li><a href="https://www.cnblogs.com/wuyepeng/p/9741241.html">C++智能指针总结</a></li></ul></li><li><p>如何在一个被const修饰的函数中修改成员变量的值</p><ul><li>设置成员变量为mutable类型</li><li>more</li></ul></li><li><p>unique_ptr和普通指针大小是否相同</p><ul><li>相同，unique_ptr零开销</li></ul></li><li><p>浏览器输入URL的过程</p><ul><li>参考以前博文</li></ul></li><li><p>HTTP报文格式，组成</p><ul><li><a href="https://www.cnblogs.com/CodingUniversal/p/7524088.html">http请求报文格式和响应报文格式</a></li><li>HTTP请求报文<ul><li>请求行、请求头部、空行、请求体</li><li>请求行：方法、URL、版本</li><li>请求头：User-Agent、Accept、Host、Cookie</li><li>空行：分割</li><li>请求体：POST</li></ul></li><li>HTTP响应报文<ul><li>状态行</li><li>响应头<ul><li>Location</li><li>Server</li><li>Connection</li><li>WWW-Authenticate</li></ul></li><li>空行</li><li>响应体</li></ul></li></ul></li><li><p>Linux改变文件权限命令</p><ul><li>chmod</li></ul></li><li><p>Linux成员有哪些</p><ul><li>所有者（owner）</li><li>用户组（group）</li><li>其它（others）</li></ul></li><li><p>Linux文件权限有哪些</p><ul><li>读</li><li>写</li><li>执行</li></ul></li><li><p>Linux的文件软连接和硬连接的区别</p><ul><li>硬连接：多个Inode执行同一个block，多重备份。</li><li>软连接：类似快捷方式，源没了就没了</li></ul></li><li><p>计算机如何表示浮点数<br><a href="https://blog.csdn.net/jvandc/article/details/81176294">浮点数在计算机中的表示</a><br><img src="https://img-blog.csdn.net/20180723223131262?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p2YW5kYw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="IEEE754"></p></li><li><p>一个URL的构成因素</p><ul><li>Scheme: 通信协议，一般为http、https等；</li><li>Host: 服务器的域名主机名或ip地址；</li><li>Port: 端口号，此项为可选项，默认为80；</li><li>Path: 目录，由“/”隔开的字符串，表示的是主机上的目录或文件地址；</li><li>Query: 查询，此项为可选项，可以给动态网页传递参数，用“&amp;”隔开，每个参数的名和值用“=”隔开；</li><li>Fragment: 信息片段，字符串，用于指定网络资源中的某片断；</li></ul></li><li><p>C++三种继承的区别</p><ul><li>Public<ul><li>基类的原本权限是什么样子就是什么样子</li></ul></li><li>Protectd<ul><li>基类的public会变成protectd</li></ul></li><li>private<ul><li>基类的访问权限全部是私有</li></ul></li></ul></li><li><p>迭代器的种类</p><ul><li><a href="https://blog.csdn.net/kai8wei/article/details/77606685">STL迭代器的种类和简介</a></li><li>输入</li><li>输出</li><li>正向</li><li>双向</li><li>随机</li></ul></li><li><p>虚函数的实现</p><ul><li>虚函数表</li></ul></li><li><p>MD5是什么</p><ul><li>哈希</li></ul></li><li><p>举一个无损压缩算法的例子</p><ul><li>算术编码</li><li>LZ77</li><li>LZSS</li><li>LZW</li></ul></li><li><p>UTF-8和Unicode的关系</p><ul><li>UTF-8是Unicode的一个具体实现</li></ul></li></ul><p><strong>项目相关</strong></p><ul><li>如何管理复杂的不同类型的接口<ul><li>版本？</li></ul></li><li>用到了Json API吗（不清楚是什么）<ul><li>或许就是json格式的API？</li></ul></li><li>项目组成</li><li>websocket工作过程</li><li>RESTful API特点<ul><li>基于资源，所有的操作都可以视为对资源的访问</li><li>统一接口，比如GET获取，POST提交，DELETE删除</li><li>无状态</li><li>鉴权</li><li>幂等性，执行多次和一次是一样的</li></ul></li></ul><p><strong>算法</strong><br>有一种彩票，票面由3位1~6的数字组成，获奖号码也是3位1~6的数字。开奖时比较票面和中奖号里相同数字的个数，2个获奖3元，3个获奖10元，其他未中奖。</p><ol><li>写一个算法，输入为票面数字及获奖号码，输出获奖金额。<br>例: <blockquote><p>输入<br>235<br>223<br>输出<br>3</p></blockquote></li></ol><ul><li>暴力，用票面数字和彩票数字对比，（不建议反过来）防止重复计算。O（MN）</li><li>哈希，记录票面数字出现，以数字为键，然后对比中奖号码。O（M+N）</li></ul><ol start="2"><li>为了提升彩票销量，运营方做了一个促销活动。购买时不限制票面的数字长度，开奖时可以自由将票面切割为多组彩票进行兑奖。<br>写一个算法，输入票面数字及获奖号码，计算可获得最大收益的兑奖额，可选：输出一种能达到最大兑奖额的切割票面方法。<br>例：<blockquote><p>输入<br>522136131221542364<br>123<br>输出<br>213 312 215 236 = 26</p></blockquote></li></ol><p><strong>Notice</strong><br>不知道怎么解<br>貌似这里一张有效的票只能是三个数字，而且重复的不算</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>不和你多bb，没过多久，灰<br>答得很一般，死有余辜</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>考虑是否应该去研习一下子Java，leetcode接着刷，最好背熟常用函数。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>计算机网络</tag>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
      <tag>客户端开发</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-4-20-4-26</title>
    <link href="/2020/04/27/leetcode-4-20-4-26/"/>
    <url>/2020/04/27/leetcode-4-20-4-26/</url>
    
    <content type="html"><![CDATA[<h3 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h3><p><a href="https://leetcode-cn.com/problems/coin-lcci/">leetcode-面试题 08.11</a></p><blockquote><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)<br>示例1:<br> 输入: n = 5<br> 输出：2<br> 解释: 有两种方式可以凑成总金额:<br>5=5<br>5=1+1+1+1+1<br>示例2:<br> 输入: n = 10<br> 输出：4<br> 解释: 有四种方式可以凑成总金额:<br>10=10<br>10=5+5<br>10=5+1+1+1+1+1<br>10=1+1+1+1+1+1+1+1+1+1<br>说明：<br>注意:<br>你可以假设：<br>0 &lt;= n (总金额) &lt;= 1000000</p></blockquote><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> total =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reChange</span><span class="params">(<span class="keyword">int</span> money, <span class="keyword">int</span> block)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(money&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(money&lt;<span class="number">5</span>) &#123;</span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(block==<span class="number">25</span>)&#123;</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-25</span>,<span class="number">25</span>);</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-10</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-5</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(block==<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-10</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-5</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(block == <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-5</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(block==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">reChange</span>(money<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reChange</span>(n,<span class="number">25</span>);</span><br><span class="line">        <span class="keyword">return</span> total%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行结果：<br>超出时间限制<br>显示详情<br>最后执行的输入：<br>900750</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>显然，这个不用动态规划说不过去，于是乎，无耻看题解，略做总结。</p><ul><li>朴素算法<br>假设现在是78美分，那么我可以这么拿<ul><li>不拿25的，78全部都是1、5、10</li><li>拿1个25，剩下的53只由1、5、10组成</li><li>拿2个25，剩下的28只由1、5、10组成</li><li>拿3个25，剩下的3只由1、5、10组成<br>若以dp[5][23]表示只有1、5两种面额组成23的种数，那么我总的种数就是$$dp[10][78]+dp[10][53]+dp[10][28]+dp[10][3]$$<br>显然，这其中的每一项又都可以用同样的方式展开，那么就可以规划了。<br>抽象出来就是$$dp[i][j]=\sum_{k=0}^{\lceil j/coin[i] \rceil}dp[i-1][j-k\times coin[i]]$$</li></ul></li></ul><p>可以写出代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个4*（n+1）的dp二维数组</span></span><br><span class="line">        <span class="comment">//多出来的1用来记录0的位置</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">4</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//硬币面额数组</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; coin&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化0的位置为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//面额为1就是1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j/coin[i];++k)&#123;</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][j-k*coin[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，此法超时</p><ul><li>第一层优化<br>隐约之中，我们好像发现，其实我们存在重复计算。<br>$$dp[25][78]=dp[10][78]+dp[10][53]+dp[10][28]+dp[10][3]$$<br>而$$dp[25][53]=dp[10][53]+dp[10][28]+dp[10][3]$$<br>那么<br>$$dp[25][78]=dp[10][78]+dp[25][53]$$<br>抽象就是<br>$$dp[i][j]=dp[i][j-coin[i]]+dp[i-1][j]$$<br>运用一下起夜级李姐的话就是：<br>$dp[i-1][j]$是一个第i种硬币都不用的种数，而$dp[i][j-coin[i]]$则运用一种包含的思想把用第i种硬币的种数都算进来了，算法优化为<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个4*（n+1）的dp二维数组</span></span><br><span class="line">        <span class="comment">//多出来的1用来记录0的位置</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">4</span>,vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//硬币面额数组</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; coin&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化0的位置为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//面额为1就是1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="comment">//此处要判断</span></span><br><span class="line">                <span class="keyword">if</span>(j-coin[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=(dp[i][j-coin[i]]+dp[i<span class="number">-1</span>][j])%<span class="number">1000000007</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//不满足就直接继承</span></span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">3</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二层优化<br>对于动态规划而言，这个时间复杂度已经到头了，但是空间复杂度还可以优化。因为我们每次就只是用到了上一层的数据，所以可以降维打击，改成一维数组。也就是原地更新数据。<br>$$dp[j]=dp[j-coin[i]]+[j]$$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个4*（n+1）的dp二维数组</span></span><br><span class="line">        <span class="comment">//多出来的1用来记录0的位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//硬币面额数组</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; coin&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化0的位置为1</span></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="comment">//此处要判断</span></span><br><span class="line">                <span class="keyword">if</span>(j-coin[i]&gt;=<span class="number">0</span>)</span><br><span class="line">                dp[j]=(dp[j-coin[i]]+dp[j])%<span class="number">1000000007</span>;</span><br><span class="line">                <span class="comment">//否则不更新</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>动态规划使人窒息</p><h3 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">面试题51. 数组中的逆序对</a></p><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>示例 1:<br>输入: [7,5,6,4]<br>输出: 5<br>限制：<br>0 &lt;= 数组长度 &lt;= 50000</p></blockquote><h4 id="稍微暴力"><a href="#稍微暴力" class="headerlink" title="稍微暴力"></a>稍微暴力</h4><p>$dp[i]=dp[i-1]+\sum_{j=0}^{i-1} nums[j]&gt;nums[i]$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;nums[i]) dp[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] += dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而，创业未半而中道崩殂<br><img src="https://tvax2.sinaimg.cn/large/a540b426gy1ge4mj3hqgnj20il05hgln.jpg" alt="image"><br><img src="https://tva2.sinaimg.cn/large/a540b426gy1ge4mju0pdxj214i084gm7.jpg" alt="image"></p><h4 id="归并教作人"><a href="#归并教作人" class="headerlink" title="归并教作人"></a>归并教作人</h4><p>其实上面的过程无非是时间复杂度为$O(n^2)$，所以只需要把时间复杂度降下来就可以了，因此可以考虑$O(nlogn)$甚至$O(n)$，本着万物皆可hash的思想，原本想hash一把梭，但是梭了20分钟没什么d用，就果断题解了。</p><p>从未想过，居然是merge，也就是分治，在合并的过程中计算逆序对数。<br>考虑如下的两个有序数列，如何寻找逆序对数目？<br>$L={8,12,16,22,100},R={9,26,55,64,91}$<br>显然，可以寻找到的逆序对数目是横跨两个序列的，因为L数组一定在R的左边。在Merge的过程中，如果发现左边的数比右边的大，那么一定有左边-左边的末尾都比右边那个大，如12大于9，那么12，16，22，100都大于9，逆序对数喜加4，那么自底向上，就可以计算出总数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeReversePairs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> mid, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oril = l;</span><br><span class="line">        <span class="keyword">int</span> orir = r;</span><br><span class="line">        <span class="keyword">int</span> rl = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = l;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid &amp;&amp; rl &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[l] &gt; tmp[rl])&#123;</span><br><span class="line">                total += (mid - l + <span class="number">1</span>);</span><br><span class="line">                num[pos++] = tmp[rl++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num[pos++] = tmp[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= mid)&#123;</span><br><span class="line">            num[pos++] = tmp[l++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rl &lt;= r)&#123;</span><br><span class="line">            num[pos++] = tmp[rl++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">copy</span>(num.<span class="built_in">begin</span>()+oril,num.<span class="built_in">begin</span>()+orir+<span class="number">1</span>,tmp.<span class="built_in">begin</span>()+oril);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reMerge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//trick 防止溢出</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">reMerge</span>(l,mid);</span><br><span class="line">            <span class="built_in">reMerge</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">            <span class="built_in">mergeReversePairs</span>(l,mid,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp = nums;</span><br><span class="line">        num = vector&lt;<span class="keyword">int</span>&gt;(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">reMerge</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里如果简单的使用=赋值符号拷贝数组会超时，需要使用stl提供的copy函数，函数原型为</p><blockquote><p>std::copy(start, end, std::back_inserter(container));</p></blockquote><p>也就是copy（开始，结束+1，目标数组开始）<br><strong>注意检查开始和结束有没有被改变，否则出了bug够你喝一壶</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>虽然难度标记为hard，但是本质还是一个归并，看来基本算法得熟记于心。</p><h3 id="4-25"><a href="#4-25" class="headerlink" title="4.25"></a>4.25</h3><p>今天力扣春季赛，败北<br>只做了第一题，还磨了1个多小时，简直了<br>第一题傻x了，先取值再排序导致拖了很久，至于其他的。。。。<br><strong>过！</strong></p><h3 id="4-46"><a href="#4-46" class="headerlink" title="4.46"></a>4.46</h3><p>今天周赛，似乎是为了安慰，题目不算难，但依旧只是做出了2题。</p><ol><li><p>第一题做着玩<br><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/">分割字符串的最大得分</a></p></li><li><p>第二题又傻逼了<br><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">可获得的最大点数</a></p></li></ol><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。<br>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。<br>你的点数就是你拿到手中的所有卡牌的点数之和。<br>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p><blockquote><p>示例 1：<br>输入：cardPoints = [1,2,3,4,5,6,1], k = 3<br>输出：12<br>解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。</p></blockquote><blockquote><p>示例 2：<br>输入：cardPoints = [2,2,2], k = 2<br>输出：4<br>解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</p></blockquote><blockquote><p>示例 3：<br>输入：cardPoints = [9,7,7,9,7,7,9], k = 7<br>输出：55<br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</p></blockquote><blockquote><p>示例 4：<br>输入：cardPoints = [1,1000,1], k = 1<br>输出：1<br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 </p></blockquote><blockquote><p>示例 5：<br>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202 </p></blockquote><blockquote><p>提示：<br>1 &lt;= cardPoints.length &lt;= 10^5<br>1 &lt;= cardPoints[i] &lt;= 10^4<br>1 &lt;= k &lt;= cardPoints.length</p></blockquote><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><p>莽递归，反手就是一个超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Tk;</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; card;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reFind</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(level==Tk)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;total) total = res;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reFind</span>(level+<span class="number">1</span>,l+<span class="number">1</span>,r,res+card[l]);</span><br><span class="line">    <span class="built_in">reFind</span>(level+<span class="number">1</span>,l,r<span class="number">-1</span>,res+card[r]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="高人指点"><a href="#高人指点" class="headerlink" title="高人指点"></a>高人指点</h4><p>其实这个题目可以转化为在一个数组里面找固定长度的字串使其和最大的问题，也就是简单的滑动窗口，只不过在这里窗口断了，需要手动连起来。<br>维护一个最大值，一个固定长度的滑动窗口，窗口从最左滑动到最右，每次滑动计算当前和并更新最大值。<br>核心在于每次滑动不需要重新计算最大值，而是减去滑出去的加上滑进来的就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cardPoints, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            max += cardPoints[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = max;</span><br><span class="line">        <span class="keyword">int</span> r = cardPoints.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            curr = curr - cardPoints[l--] + cardPoints[r--];</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; max)&#123;</span><br><span class="line">                max = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三题尝试了一下，但是在第二题浪费了太多时间，没有好的算法，超时了。<br><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii/">对角线遍历 II</a><br>给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。</li></ol><p> </p><p>示例 1：<br><img src="https://tva3.sinaimg.cn/large/a540b426gy1ge8n7p0hfkj204e03zt8k.jpg" alt="img"></p><blockquote><p>输入：nums = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,4,2,7,5,3,8,6,9]</p></blockquote><p>示例 2：<br><img src="https://tvax2.sinaimg.cn/large/a540b426gy1ge8n7p5pk5j206e04x3yj.jpg" alt="img"></p><blockquote><p>输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]<br>输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]<br>输出：[1,4,2,5,3,8,6,9,7,10,11]</p></blockquote><p>示例 4：</p><blockquote><p>输入：nums = [[1,2,3,4,5,6]]<br>输出：[1,2,3,4,5,6] </p></blockquote><p>提示：</p><blockquote><p>1 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i].length &lt;= 10^5<br>1 &lt;= nums[i][j] &lt;= 10^9<br>nums 中最多有 10^5 个数字。</p></blockquote><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>直接从最左边开始模拟遍历，问题在于会遍历很多不存在的位置，导致超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> X = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> Y = nums[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;val :nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val.<span class="built_in">size</span>()&gt;Y) Y = val.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(level&lt;X+Y)&#123;</span><br><span class="line">            x = level;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;x&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(x &lt; X &amp;&amp; y &lt; nums[x].<span class="built_in">size</span>())</span><br><span class="line">                    res.<span class="built_in">push_back</span>(nums[x][y]);</span><br><span class="line">                <span class="keyword">if</span>(y&gt;Y)<span class="keyword">break</span>;</span><br><span class="line">                --x;</span><br><span class="line">                ++y;</span><br><span class="line">            &#125;</span><br><span class="line">            ++level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>不难发现，每一组的和是相等的，那么可以以和最为键，把结果有序存起来，迁移即可。<br>注意这里是从下网上走的，那么下面的在前面，因此需要行从后往前遍历。<br>列从左往右。<br>那么可以想到的数据容器就是map了，自动排序，天作之合！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[i].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                v[i+j].<span class="built_in">push_back</span>(nums[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;vec:v)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span>&amp;val:vec.second)</span><br><span class="line">                res.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>tip</strong><br>map内的vector无需初始化</p><ol start="4"><li>第四题看都没看<br><a href="https://leetcode-cn.com/problems/constrained-subset-sum/">带限制的子序列和</a><br>给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i &lt; j 且 j - i &lt;= k 。<br>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</li></ol><p> </p><p>示例 1：</p><blockquote><p>输入：nums = [10,2,-10,5,20], k = 2<br>输出：37<br>解释：子序列为 [10, 2, 5, 20] 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [-1,-2,-3], k = 1<br>输出：-1<br>解释：子序列必须是非空的，所以我们选择最大的数字。</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [10,-2,-10,-5,20], k = 2<br>输出：23<br>解释：子序列为 [10, -2, -5, 20] 。 </p></blockquote><p>提示：</p><blockquote><p>1 &lt;= k &lt;= nums.length &lt;= 10^5<br>-10^4 &lt;= nums[i] &lt;= 10^4</p></blockquote><h3 id="引题"><a href="#引题" class="headerlink" title="引题"></a>引题</h3><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a><br>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例:</p><blockquote><p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释:<br>  滑动窗口的位置                最大值<br>-------——–               —–<br>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7 </p></blockquote><p>提示：</p><blockquote><p>1 &lt;= nums.length &lt;= 10^5<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>1 &lt;= k &lt;= nums.length</p></blockquote><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>维护一个deque&lt;双向队列&gt;，头部是最大值，往后依次递减，每次进队列时候需要把比要进去的数小的弹出来，从而保证有序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; window;</span><br><span class="line">        window.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size()-k+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!window.<span class="built_in">empty</span>()&amp;&amp;nums[window.<span class="built_in">back</span>()] &lt; nums[i]) window.<span class="built_in">pop_back</span>();</span><br><span class="line">            window.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>]=nums[window.<span class="built_in">front</span>()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!window.<span class="built_in">empty</span>()&amp;&amp;nums[window.<span class="built_in">back</span>()] &lt; nums[i]) window.<span class="built_in">pop_back</span>();</span><br><span class="line">            window.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i-window.<span class="built_in">front</span>()==k) window.<span class="built_in">pop_front</span>();</span><br><span class="line">            res[i-k+<span class="number">1</span>] = nums[window.<span class="built_in">front</span>()];        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="扩展-变形"><a href="#扩展-变形" class="headerlink" title="扩展/变形"></a>扩展/变形</h4><p>与上面的不同，本题找的是子序列，而且还有负值，那么需要考虑到中间某些元素不能取，假设dp[i]是以元素i结尾的最大子序列的值，那么dp[i]要么加上dp[i-1](dp[i-1]&gt;0),要么从头开始，也就是<br>$$dp[i]=max(dp[i-1]+nums[i],nums[i])$$<br>同时利用双向队列维护子序列的长度关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; window;</span><br><span class="line">        window.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//res为最大值</span></span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="comment">//更新dp</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[window.<span class="built_in">front</span>()]+nums[i],nums[i]);</span><br><span class="line">            <span class="comment">//更新res</span></span><br><span class="line">            res = <span class="built_in">max</span>(dp[i],res);</span><br><span class="line">            <span class="comment">//维护有序</span></span><br><span class="line">            <span class="keyword">while</span>(!window.<span class="built_in">empty</span>() &amp;&amp; dp[window.<span class="built_in">back</span>()] &lt; dp[i]) window.<span class="built_in">pop_back</span>();</span><br><span class="line">            window.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(window.<span class="built_in">back</span>()-window.<span class="built_in">front</span>()==k)window.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>有几天的日题没做，还是得做</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构简单复读</title>
    <link href="/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为忘得差不多了，就简单系统复习一下数据结构</p><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol><li><p>从有序顺序表删除重复<br> 维护一个非重复有序表，起始为第一个元素，向后判断是否重复，如果重复就pass，否则就插入非重复有序表（交换），直到结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_dupicate</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="built_in">list</span> + i) != *(<span class="built_in">list</span> + pos))</span><br><span class="line">        &#123;</span><br><span class="line">            *(<span class="built_in">list</span> + pos + <span class="number">1</span>) = *(<span class="built_in">list</span> + i);</span><br><span class="line">            pos += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = del_dupicate(a, <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无序顺序表、使用hash表</p></li><li><p>合并两个有序顺序表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *l1, <span class="keyword">int</span> len1, <span class="keyword">int</span> *l2, <span class="keyword">int</span> len2, <span class="keyword">int</span> *l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(l1 + i) &lt;= *(l2 + j))</span><br><span class="line">        &#123;</span><br><span class="line">            *(l3 + k) = *(l1 + i);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *(l3 + k) = *(l2 + j);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1)</span><br><span class="line">    &#123;</span><br><span class="line">        *(l3 + k) = *(l1 + i);</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len2)</span><br><span class="line">    &#123;</span><br><span class="line">        *(l3 + k) = *(l2 + j);</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1[<span class="number">11</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> l2[<span class="number">6</span>] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> l3[<span class="number">17</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    merge(l1, <span class="number">11</span>, l2, <span class="number">6</span>, l3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A[m+n] -&gt; A[n+m] 顺序不变<br>现全部逆置，再别对n和m逆置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (n + m) / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = *(<span class="built_in">list</span> + i);</span><br><span class="line">        *(<span class="built_in">list</span> + i) = *(<span class="built_in">list</span> + n + m - <span class="number">1</span> - i);</span><br><span class="line">        *(<span class="built_in">list</span> + n + m - <span class="number">1</span> - i) = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = *(<span class="built_in">list</span> + i);</span><br><span class="line">        *(<span class="built_in">list</span> + i) = *(<span class="built_in">list</span> + n - <span class="number">1</span> - i);</span><br><span class="line">        *(<span class="built_in">list</span> + n - <span class="number">1</span> - i) = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = *(<span class="built_in">list</span> + i + n);</span><br><span class="line">        *(<span class="built_in">list</span> + i + n) = *(<span class="built_in">list</span> + n + m - <span class="number">1</span> - i);</span><br><span class="line">        *(<span class="built_in">list</span> + n - <span class="number">1</span> - i + m) = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">9</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">33</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    reverse2(<span class="built_in">list</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>移位算法<br>将A[mn] -&gt; A[nm],同上</p></li><li><p>等长升序序列A，B找中位数。</p><ol><li>求A、B中位数—a—，—b—,若a=b，结束</li><li>a&lt;b，留下b— —a</li><li>a&gt;b，留下a— —b,并重复1，2，3<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_mid_AB</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>, e1 = len - <span class="number">1</span>, s2 = s1, e2 = e1, m1, m2;</span><br><span class="line">    <span class="keyword">while</span> (s1 != e1)</span><br><span class="line">    &#123;</span><br><span class="line">        m1 = (e1 + s1) / <span class="number">2</span>;</span><br><span class="line">        m2 = (e2 + s2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[m1] == B[m2])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[m1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((e1 - s1) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[m1] &lt; B[m2])</span><br><span class="line">            &#123;</span><br><span class="line">                s1 = m1 + <span class="number">1</span>;</span><br><span class="line">                e2 = m2 - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s2 = m2 + <span class="number">1</span>;</span><br><span class="line">                e1 = m1 - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[m1] &lt; B[m2])</span><br><span class="line">            &#123;</span><br><span class="line">                s1 = m1 + <span class="number">1</span>;</span><br><span class="line">                e2 = m2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s2 = m2 + <span class="number">1</span>;</span><br><span class="line">                e1 = m1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[s1] &lt; B[s2] ? A[s1] : B[s2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> B[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> res = find_mid_AB(A, B, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3></li></ol></li></ol><ul><li>非随机，也就是不能直接访问</li><li>头插法、尾插法建立链表</li><li>插入节点</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = getElem(L,i<span class="number">-1</span>);<span class="comment">//找到位置i的前驱节点</span></span><br><span class="line">s -&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next = s;</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><ul><li>插入,在p后面插入s<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; next = p -&gt; next;</span><br><span class="line">p -&gt; next -&gt; prior = s;</span><br><span class="line">p -&gt; next = s;</span><br><span class="line">s -&gt; prior = p;</span><br></pre></td></tr></table></figure></li><li>删除p后的节点q<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; next = q -&gt; next;</span><br><span class="line">q -&gt; next -&gt; prior =q;</span><br><span class="line">q -&gt; next = q -&gt; prior = null;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3></li><li>存取方式<br>前者可以随机和顺序，后者只能顺序</li><li>逻辑结构和物理结构</li><li>查找、插入、删除</li><li>空间分配</li></ul><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>顺序栈，数组从栈底到栈顶存储，会发生上溢</li><li>共享栈，数组两端为两个栈的栈底，向中间扩充</li><li>链栈，链表头指针指向栈顶，多个栈共享存储空间，且不会上溢</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>队列的顺序存储，数组从前往后为队头和队尾，从队尾入队从头出队，当front = rear时队空，但是如果数组的长度有限，会出现假溢出。</li><li>循环队列，从逻辑上视作一个环，rear入队增加，front出队也增加。当（rear+1）%MaxSize = front时满，当rear=front时空，元素个数为（rear-front+MaxSize）%MaxSize</li><li>链式队列，适合变动大的队列</li><li>双端队列</li></ul><h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><p>顺序扫描后缀表达式，如果是操作树就压入栈中，如果是运算符就弹出两个操作数进行运算将结果压入栈中，直到最后就是结果</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h4 id="消息队列等"><a href="#消息队列等" class="headerlink" title="消息队列等"></a>消息队列等</h4><h3 id="特殊矩阵压缩存储"><a href="#特殊矩阵压缩存储" class="headerlink" title="特殊矩阵压缩存储"></a>特殊矩阵压缩存储</h3><ul><li>对称矩阵</li><li>上下三角矩阵</li><li>带状矩阵</li><li>稀疏矩阵</li></ul><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ul><li>N个节点的有限集合</li><li>一个节点的子节点数称为度，最大的称为树的度</li><li>分支节点（du大于0），叶子节点（度等于0）</li><li>结点深度从根向下</li><li>结点高度从叶子向上</li><li>树的高度为树中结点的最大层次</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul><li>有序树</li><li>每个结点至多两个子树，可无</li><li>满二叉树：满的，每一层都是最多的</li><li>完全二叉树：也就是其结点序号从上到下，从左到右密集，和满二叉树对应。</li><li>二叉排序树，所有结点满足左&lt;父&lt;右</li><li>平衡二叉树：任意结点的左子树和右子树深度之差不超过1</li></ul><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><ul><li><p>先序遍历：根-&gt;左-&gt;右</p><ul><li><p>递归版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT)&#123;</span><br><span class="line">        visit(BT);</span><br><span class="line">        PreOrderTraversal(BT-&gt;lNode);</span><br><span class="line">        PreOrderTraversal(BT-&gt;rNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>非递归版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    S.InitialStack();</span><br><span class="line">    BinTree p = BT;<span class="comment">//pointer</span></span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            push(S,p);</span><br><span class="line">            p = p -&gt; lNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p = pop(S);</span><br><span class="line">            p = p -&gt; rNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>中序遍历：左-&gt;根-&gt;右<br>方法类似上面</p></li><li><p>后序遍历：左-&gt;右-&gt;根</p><ul><li>递归版本类似</li><li>非递归<br>先左-&gt;右-&gt;中，那么如果按照中右左的顺序入栈，就可以按照左右中的顺序出栈，因此可以将先序遍历的结果存储在一个辅助栈中再输出<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    Stack S2;</span><br><span class="line">    S.InitialStack();</span><br><span class="line">    S2.InitialStack();</span><br><span class="line">    BinTree p = BT;<span class="comment">//pointer</span></span><br><span class="line">    <span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            push(S2,p);<span class="comment">//把访问改为入栈</span></span><br><span class="line">            push(S,p);</span><br><span class="line">            p = p -&gt; rNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p = pop(S);</span><br><span class="line">            p = p -&gt; lNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(S2))&#123;</span><br><span class="line">        visit(pop(S2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>层次遍历<br>借助一个队列，先进先出，自上而下的扫描左右结点并入队，然后对每一个出队的元素，执行同样的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BinTree BT)</span></span>&#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    Q.InitialQueue();</span><br><span class="line">    BinTree p;</span><br><span class="line">    Q.EnQueue(BT);</span><br><span class="line">    <span class="keyword">while</span>(isEmpty(Q))&#123;</span><br><span class="line">        p = Q.DeQueue();</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lNode)&#123;</span><br><span class="line">            Q.EnQUeue(p-&gt;lNode);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p -&gt; rNode)&#123;</span><br><span class="line">            Q.EnQueue(p -&gt; rNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>依据遍历结果构造二叉树</p><ul><li>先序和中序<ul><li>先序的第一个为根节点，中序的根结点分成左右子树</li></ul></li><li>后序和中序<ul><li>后序的最后一个为根，中序分割</li></ul></li><li>先序和后序<ul><li>无解</li></ul></li><li>层次和中序<ul><li>层次遍历确定根结点，中序分割</li></ul></li></ul></li></ul><h3 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h3><ul><li>双亲表示：连续存储，增设一个父节点的位置标记</li><li>孩子表示法：结点单列一个数组，每个结点链接所有的孩子，从左到右</li><li>孩子兄弟表示法：存储节点值和节点第一个孩子指针和节点第一个兄弟指针</li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h3 id="二叉排序树-二叉查找树（BST）"><a href="#二叉排序树-二叉查找树（BST）" class="headerlink" title="二叉排序树/二叉查找树（BST）"></a>二叉排序树/二叉查找树（BST）</h3><p>左&lt;根&lt;右</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><ul><li>递归<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode * <span class="title">BST_Search</span><span class="params">(BT T,<span class="keyword">int</span> key,BSTNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;*p) BST_Search(T-&gt;lchild,key,p)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == *p) <span class="keyword">return</span> p</span><br><span class="line">    <span class="keyword">else</span> BST_Search(T-&gt;rchild,key,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>非递归<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BT T,<span class="keyword">int</span> key,BSTNode *p)</span></span>&#123;</span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;key!=T-&gt;data)&#123;</span><br><span class="line">        p=T;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;data) T=T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> T=T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a><strong>插入</strong></h4>插入到叶结点</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h4><ul><li>若被删除的节点的左子树为空，则用右子女填补</li><li>如右子树空，则用左子女填补</li><li>若都不为空，在右子树上找最小的，也就是中序的第一个节点<h4 id="二叉排序树VS二分查找"><a href="#二叉排序树VS二分查找" class="headerlink" title="二叉排序树VS二分查找"></a><strong>二叉排序树VS二分查找</strong></h4>二叉排序树无需要移动结点，插入删除操作的复杂度为O（logn），二分查找为有序表，插入删除的复杂度为O（n），如果有序表是静态表，就选择二分查找，动态的就选择二叉排序树。</li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>任意结点左右子树高度差的绝对值不超过1</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a><strong>旋转</strong></h4><ul><li>LL，left child left subtree （右单旋）<br><img src="https://tva1.sinaimg.cn/large/a540b426gy1gde3ydnnkaj20mv097q68.jpg" alt="LL"></li><li>RR（左单旋）<br><img src="https://tva2.sinaimg.cn/large/a540b426gy1gde3yec9bwj20p2099q8i.jpg" alt="RR"></li><li>LR（先左后右双旋转）<br><img src="https://tva3.sinaimg.cn/large/a540b426gy1gde3ydutsbj20mt0arteo.jpg" alt="LR"></li><li>RL（先右后左）<br><img src="https://tva1.sinaimg.cn/large/a540b426gy1gde3ye5rncj20mc0a4tes.jpg" alt="RL"></li></ul><h3 id="哈夫曼树-最优二叉树"><a href="#哈夫曼树-最优二叉树" class="headerlink" title="哈夫曼树/最优二叉树"></a>哈夫曼树/最优二叉树</h3><p>$$WPL=\sum^{n}_{i=1}w_i\times l_i$$<br>所有结点的带权路径长度之和最小的树，w权重，l路径长度（经过的边数）</p><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a><strong>构造</strong></h4><ul><li>选取最小-&gt;新节点-&gt;选取最小-&gt;新节点-&gt;…<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a><strong>哈夫曼编码</strong></h4></li><li>可变长度编码/数据压缩</li><li>前缀码/解码</li></ul><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li><p><strong>广度优先搜索</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i in visited) i=<span class="literal">false</span>;<span class="comment">//初始化访问数组</span></span><br><span class="line">    initialQueue(Q);<span class="comment">//初始化一个队列用来辅助</span></span><br><span class="line">    <span class="keyword">for</span>(node in G) <span class="keyword">if</span>(!visited[i]) BFS(G,node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">    visit(v);<span class="comment">//首先访问顶点</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    Enqueue(Q,v);<span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">while</span>(!empty(Q))&#123;</span><br><span class="line">        Dequeue(Q,v);</span><br><span class="line">        <span class="keyword">for</span>(sudnode in v.neighbor)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[subnode])&#123;</span><br><span class="line">                visit(subnode);</span><br><span class="line">                visited[subnode]=<span class="literal">true</span>;</span><br><span class="line">                Enqueue(Q,subnode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>单源最短路径</strong><br>利用BFS，从顶点开始，记录和源点的距离，BFS遍历，未访问过就+1</p></li><li><p><strong>深度优先搜素</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i in visited) i = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(v in G) DFS(G,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v]=TRUE;</span><br><span class="line">    <span class="keyword">for</span>(subnode in v.nerghbor)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[subnode])&#123;</span><br><span class="line">            DFS(G,subnode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3></li><li><p><strong>Prim算法</strong><br>首先随机选择一个顶点，每次都选权值最小的边的顶点加入，直到全部的顶点都加入。<br>时间复杂度$O(|V|^2)$</p></li></ul><ul><li><strong>Kruskal算法</strong><br>首先所有的顶点都加入到结果集合中，然后将边排好序，选择最小的不构成回路的边，直到形成一个连通图为止。<br>时间复杂度$O(|E|log|E|)$，适用于边稀疏而顶点较多的图。</li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li>Dijkstra算法求单源最短路径<br>求带权图中某个源点到其余各顶点的最短路径，首先定义以下的变量，<br>dist[]：记录从源点v0到其他各个顶点当前的最短路径长度，初值为边权<br>path[]:path[i]表示从v0到i之间的最短路径的前驱结点，可以还原路径。<br>首先需要获取从&lt;i,j&gt;权值，没边为无穷<ol><li>初始化：集合S初始化为{0}，dist[]的初始值dist[i]为0到各点初始路径</li><li>选择dist[]最小的j加入到S</li><li>更新dist[k],k为任意顶点</li><li>重复2，3步骤直到所有点都加入<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a><strong>Floyd算法</strong></h3><a href="https://www.cnblogs.com/wangyuliang/p/9216365.html">Floyd-傻子也能看懂的弗洛伊德算法</a><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><img src="https://tva1.sinaimg.cn/large/a540b426gy1gdelwr1z8rj20hk0bstcs.jpg" alt="查找"><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a><strong>顺序查找</strong></h3>略<h3 id="折半-二分查找"><a href="#折半-二分查找" class="headerlink" title="折半/二分查找"></a><strong>折半/二分查找</strong></h3>略<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3>吸收顺序和二分的优点<br><img src="https://tva3.sinaimg.cn/large/a540b426gy1ge3u9y0ltaj20oo07iae5.jpg" alt="image"><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a><strong>B树</strong></h3>多路平衡查找树，B树中所有结点的孩子节点数的最大值为B树的阶，通常用m表示。</li><li>树中每个结点至多有m棵子树</li><li>若根结点不是终端结点，则至少有两棵子树</li><li>除根结点外所有非叶子结点$\lceil m/2 \rceil$棵子树，也就是至少$\lceil m/2 \rceil-1$</li><li>n-P0-K1-P1-K2-P2-…-Kn-Pn（结点构成，n为结点中关键字的个数）</li><li>叶子结点都在同一层，实际上不存在，上一层直接指向空<br><img src="https://tvax2.sinaimg.cn/large/a540b426gy1gdenfn2nvkj20hb07etc3.jpg" alt="3阶B树"> <h4 id="查找-2"><a href="#查找-2" class="headerlink" title="查找"></a>查找</h4><h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4></li></ol><ul><li>若插入后关键字小于m，直接插入</li><li>否则要分裂，从中间分开，中间的提上去，两边称为左右子树，直到满足条件<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4></li><li>若所删除的关键字k不在终端结点-&gt;合并，删除</li><li>若在终端结点，直接删除或者找兄弟借<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a><strong>B+树</strong></h3>B+树是B树的一种变形树，m阶的B+树满足下列条件</li></ul></li><li>每个分支结点最多有m棵子树/子结点</li><li>非叶根结点至少有两棵子树，其它分支结点至少$\lceil m/2 \rceil$棵子树。</li><li>结点子树个数与关键字相等</li><li>所有叶结点包括了所有的关键字和指针，并且叶结点中将关键字按大小顺序排列，相邻叶结点按照大小顺序相互链接。</li><li>分支结点仅包括其各个子结点中关键字的最大值和指针<h3 id="B树-VS-B-树"><a href="#B树-VS-B-树" class="headerlink" title="B树 VS B+树"></a><strong>B树 VS B+树</strong></h3></li><li>B+树中具有n各关键字的结点只有n棵子树，B树有n+1</li><li>m和每个结点关键字的个数关系</li><li>B+树，叶结点包含信息，所有非叶结点仅起到索引作用，因为它只包含子树中最大的关键字的数据和子树地址而没有该关键字的对应存储地址（索引的索引）</li><li>B+树中叶结点包含了所有的关键字，即使是在非也结点出现的关键字也会出现在叶结点中，而在B树中是不重复的。<h3 id="B-树与MySQL"><a href="#B-树与MySQL" class="headerlink" title="B+树与MySQL"></a><strong>B+树与MySQL</strong></h3></li><li>MySQL使用B+树做索引</li><li>B+树非叶子结点只存储索引的key值，不存储value，所以相比于B树能够存放更多的索引，节省空间</li><li>B+树的查询无论成功与否都要到叶子结点，因此不同数据的查询时趋于稳定的。</li><li>B+树在叶子结点中顺序存放了数据，因此可以非常方便的实现遍历</li></ul><h3 id="散列-Hash"><a href="#散列-Hash" class="headerlink" title="散列/Hash"></a><strong>散列/Hash</strong></h3><ul><li>散列构造</li><li><strong>冲突解决</strong><ul><li>开放定址：存在不属于它的位置<ul><li>线性探查：冲突就存放在下一个位置，顺延</li><li>平方探查：避免了聚集，但是不能读取到所有位置</li><li>再散列：重新生成位置</li><li>伪随机：伪随机生成一个位置</li></ul></li><li>开链：在原位置开一个链表存储</li></ul></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>时间复杂度<br>空间复杂度w<br>稳定性：相同元素顺序不变<br><img src="https://tva4.sinaimg.cn/large/a540b426gy1ge3tygle3mj20g20amwih.jpg" alt="sort"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>有序序列L[1…i-1] <strong>|</strong> L(i) <strong>|</strong> 无序序列L[i+1…n]<br>就像整理一副扑克牌一样，最直观的排序</p><ul><li>时间复杂度$O(n^2)$</li><li>稳定性：稳定，因为相同的元素不需要交换</li><li>适用性：顺序表和链式表<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = *(<span class="built_in">list</span> + i);</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="built_in">list</span> + i) &lt; *(<span class="built_in">list</span> + i - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; *(<span class="built_in">list</span> + j) &gt; tmp &amp; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                *(<span class="built_in">list</span> + j + <span class="number">1</span>) = *(<span class="built_in">list</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">            *(<span class="built_in">list</span> + j + <span class="number">1</span>) = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4>在寻找插入位置的时候使用了二分/折半查找，减少了比较次数</li></ul><h4 id="希尔排序（shell）-缩小增量排序"><a href="#希尔排序（shell）-缩小增量排序" class="headerlink" title="希尔排序（shell）/缩小增量排序"></a>希尔排序（shell）/缩小增量排序</h4><p>等间隔D0分组排序，等间隔D1分组排序，等间隔D2分组。。。等间隔1分组，组内采用插入排序</p><ul><li>时间复杂度：最坏$O(n^2)$ 平均 $O(n^{1.3})$</li><li>稳定性：不稳定</li><li>适用性：线性表</li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a><strong>交换排序</strong></h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>依次比较或交换相邻两个元素，每次都把最大/小的元素放在末尾</p><ul><li>时间复杂度：最好$O(n)$(有序，无交换) 平均最坏 $O(n^2)$</li><li>稳定性：稳定<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h4>基于分治思想，选择一个pivot，分成两个部分，左&lt;pivot&lt;右，递归调用，直到空或1个元素。性能取决于划分操作。<br>划分版本：1、选择第一个 2、选择首中尾的中间值</li><li>时间复杂度：最坏$O(n^2)$，选取的元素为最值 最好&amp;平均$O(nlogn)$</li><li>稳定性：不稳定<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = *(<span class="built_in">list</span> + l);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (*(<span class="built_in">list</span> + r) &gt;= pivot &amp;&amp; l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        *(<span class="built_in">list</span> + l) = *(<span class="built_in">list</span> + r);</span><br><span class="line">        <span class="keyword">while</span> (*(<span class="built_in">list</span> + l) &lt;= pivot &amp;&amp; l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        *(<span class="built_in">list</span> + r) = *(<span class="built_in">list</span> + l);</span><br><span class="line">    &#125;</span><br><span class="line">    *(<span class="built_in">list</span> + l) = pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotPos = Partition(<span class="built_in">list</span>, l, r);</span><br><span class="line">        QuickSort(<span class="built_in">list</span>, l, pivotPos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(<span class="built_in">list</span>, pivotPos + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h3><h4 id="简单选择-每次选最大-最小"><a href="#简单选择-每次选最大-最小" class="headerlink" title="简单选择-每次选最大/最小"></a>简单选择-每次选最大/最小</h4></li><li>时间复杂度：$O(n^2)$</li><li>稳定性：不稳定，交换会打乱位置<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &lt; v[min])</span><br><span class="line">            &#123;</span><br><span class="line">                v[j] = v[j] ^ v[min];</span><br><span class="line">                v[min] = v[j] ^ v[min];</span><br><span class="line">                v[j] = v[j] ^ v[min];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4>树形选择排序,通过构建大顶堆/小顶堆选择元素。</li><li>堆的构建（以大顶堆为例）<ul><li>找到最后一个非叶结点，依次往前调整</li><li>每次进行了交换之后，需要将交换过的结点重新调整直到叶结点</li></ul></li><li>时间复杂度：最好/最坏/平均 $O(nlogn)$</li><li>稳定性：不稳定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;list, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k + <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (list[i] &lt; list[i + <span class="number">1</span>] &amp;&amp; i &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list[i] &lt; list[k])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            list[k] = list[k] ^ list[i];</span><br><span class="line">            list[i] = list[k] ^ list[i];</span><br><span class="line">            list[k] = list[k] ^ list[i];<span class="comment">//奇怪的交换增加了</span></span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (list.<span class="built_in">size</span>() - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(list, i, list.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">BuildHeap</span>(list);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = list[<span class="number">0</span>];</span><br><span class="line">        list[<span class="number">0</span>] = list[i];</span><br><span class="line">        list[i] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AdjustDown</span>(list, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; list[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4>将<strong>两个或两个以上</strong>有序表组合成新的有序表，自底向上。<br><img src="https://tvax4.sinaimg.cn/large/a540b426gy1gdgx56r431j20hu08n77c.jpg" alt="归并"></li><li>空间效率 $O(n)$</li><li>时间效率：$O(n)\times \lceil log_2n \rceil = O(nlog_2n)$</li><li>稳定性：稳定</li><li>手撕代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">back</span><span class="params">(list.begin(), list.begin() + m)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> rl = m;</span><br><span class="line">    <span class="keyword">int</span> pos = l;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; m &amp;&amp; rl &lt; r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (back[l] &lt;= list[rl])</span><br><span class="line">        &#123;</span><br><span class="line">            list[pos++] = back[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            list[pos++] = list[rl++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        list[pos++] = back[l++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (rl &lt; r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        list[pos++] = list[rl++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(l, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">Merge</span>(l, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; l = &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    list = l;</span><br><span class="line">    <span class="built_in">MergeSort</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4>多关键字排序思想，适用于数字排序，字符串也可用。<br>有高位优先（MSD）和低位优先（LSD）两种。<br>不多bb，看例子<br><img src="https://tvax4.sinaimg.cn/large/a540b426gy1ge3t74bnz2j20ly08zq9p.jpg" alt="image"></li></ul><p>先考察个位，再十位，再百位</p><ul><li>空间效率：O(r)，r是基数位数这里是10</li><li>时间效率：O(d(n+r))，本例种d为3，n为7</li><li>稳定性：绝逼稳定，不然排不出来</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] 2019考研复习指导<br>[2] 博客，侵删</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这篇文章陆陆续续写了一个多月，其实挺早的时候就基本完工了，但是因为忙其它的去了，就搁置了。其实写到现在，也就又还回去了，为了方便阅读，就整理一下发出来。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode_4.13-4.19</title>
    <link href="/2020/04/23/leetcode-4-13-4-19/"/>
    <url>/2020/04/23/leetcode-4-13-4-19/</url>
    
    <content type="html"><![CDATA[<h3 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h3><p><a href="https://leetcode-cn.com/problems/jump-game/">leetcode-55. 跳跃游戏</a></p><blockquote><p>  给定一个非负整数数组，你最初位于数组的第一个位置。<br>    数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>    判断你是否能够到达最后一个位置。<br>    示例 1:</p></blockquote><pre><code>输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。示例 2:输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</code></pre><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><ul><li><p>我的解法：递归，倒着找。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reCanJump</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;target;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n[i]&gt;=target-i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">reCanJump</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        n=nums;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reCanJump</span>(len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  1400ms/8.2MB</p></li><li><p>官方：维护一个最大跳跃距离，从0-n更新，如果当前步数能够跳的更远就更新，否则不更新。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxDis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxDis &gt;=len<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(maxDis&lt;i+nums[i]) maxDis = i+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(maxDis&lt;=i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  8ms/7.6MB</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>动态规划！！！</p><h3 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">leetcode-11.盛最多水的容器</a><br><img src="https://tva4.sinaimg.cn/large/a540b426gy1gdxo3pen39j20hv0jjt9o.jpg" alt="leetcode-11"></p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p><strong>双指针法</strong><br>维护两个指针，起始分别指向两端，同时记录最大的盛水量，接着移动较短的指针（避免短板效应，移动短的可能出现盛水量增加的情况，移动长的一定减少），比较并决定是否更新最大盛水量。</p><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><ul><li>leetcode 模式  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">min</span>(height[l],height[r])*(r-l);</span><br><span class="line">            <span class="keyword">if</span>(tmp&gt;maxA) maxA=tmp;</span><br><span class="line">            <span class="keyword">if</span>(height[l]&lt;=height[r])</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxWater = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmpWater = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;height[r])&#123;</span><br><span class="line">                tmpWater = height[r]*(r-l);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmpWater = height[l]*(r-l);</span><br><span class="line">            &#125;</span><br><span class="line">            maxWater = (tmpWater &gt; maxWater) ? tmpWater : maxWater;</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;height[r])&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">    l,r = <span class="number">0</span>,<span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">    maxWater = <span class="number">0</span></span><br><span class="line">    tmpWater = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(l!=r):</span><br><span class="line">        tmpWater = <span class="built_in">min</span>(height[l],height[r])*(r-l)</span><br><span class="line">        maxWater = tmpWater <span class="keyword">if</span> tmpWater &gt; maxWater <span class="keyword">else</span> maxWater</span><br><span class="line">        <span class="keyword">if</span>(height[l]&gt;height[r]):</span><br><span class="line">            r-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> maxWater</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> r = height.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> maxWater = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> tmpWater = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(l!=r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(height[l]&gt;height[r])&#123;</span><br><span class="line">        tmpWater = height[r]*(r-l);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tmpWater = height[l]*(r-l);</span><br><span class="line">    &#125;</span><br><span class="line">    maxWater = tmpWater &gt; maxWater ? tmpWater : maxWater;</span><br><span class="line">    <span class="keyword">if</span>(height[l]&gt;height[r])&#123;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxWater;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>手撕模式  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">min</span>(height[l], height[r]) * (r - l);</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; maxA)</span><br><span class="line">            maxA = tmp;</span><br><span class="line">        <span class="keyword">if</span> (height[l] &lt;= height[r])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; height = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxArea</span>(height);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4>双指针法对求解类似问题有奇效</li></ul><h3 id="周记"><a href="#周记" class="headerlink" title="周记"></a>周记</h3><p>只搞了两题，水了水了。。。    </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见面试题杂记</title>
    <link href="/2020/04/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%9D%82%E8%AE%B0/"/>
    <url>/2020/04/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="磁盘寻道算法"><a href="#磁盘寻道算法" class="headerlink" title="磁盘寻道算法"></a>磁盘寻道算法</h3><ul><li>FCFS:先来先服务</li><li>SSTF：最短寻道时间优先</li><li>SCAN：（电梯调度）扫描算法</li><li>CSCAN：循环扫描算法</li></ul><h3 id="进程线程区别"><a href="#进程线程区别" class="headerlink" title="进程线程区别"></a>进程线程区别</h3><ul><li>进程是操作进行资源分配的基本单位</li><li>线程是任务调度和执行的基本单位</li><li>线程有自己的运行栈和程序计数器PC</li><li>线程使用资源来自其所属进程</li></ul><h3 id="URL到页面渲染"><a href="#URL到页面渲染" class="headerlink" title="URL到页面渲染"></a>URL到页面渲染</h3><ul><li>DNS</li><li>TCP</li><li>HTTP请求</li><li>服务器响应</li><li>浏览器解析</li><li>获取静态资源</li><li>渲染页面</li></ul><h3 id="DNS查找-解析的过程"><a href="#DNS查找-解析的过程" class="headerlink" title="DNS查找/解析的过程"></a>DNS查找/解析的过程</h3><ul><li>浏览器缓存</li><li>系统缓存</li><li>路由器缓存</li><li>根域名服务器</li><li>顶级域名</li><li>主域名服务器</li></ul><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a><strong>虚函数</strong></h3><ul><li>指向子类的父类指针调用子类中与父类同名的方法</li><li>实现运行时多态</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>对于不同对象接收相同消息时产生不同的动作</li><li><strong>编译时多态</strong><ul><li>函数和运算符的重载</li></ul></li><li><strong>运行时多态</strong><ul><li>虚函数和继承</li></ul></li><li><strong>优点</strong><ul><li>代码复用</li><li>扩展</li><li>接口</li><li>参数统一</li><li>维护性</li></ul></li><li><strong>缺点</strong><ul><li>不能使用子类的成员</li></ul></li></ul><h3 id="重载-amp-重写"><a href="#重载-amp-重写" class="headerlink" title="重载&amp;重写"></a>重载&amp;重写</h3><ul><li>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</li><li>重写：是指子类重新定义父类虚函数的方法。</li></ul><h3 id="多继承-amp-菱形继承"><a href="#多继承-amp-菱形继承" class="headerlink" title="多继承&amp;菱形继承"></a>多继承&amp;菱形继承</h3><ul><li>可能出现菱形继承问题，可以虚继承</li></ul><h3 id="ping协议-ICMP，控制报文协议"><a href="#ping协议-ICMP，控制报文协议" class="headerlink" title="ping协议/ICMP，控制报文协议"></a>ping协议/ICMP，控制报文协议</h3><ul><li>ICMP，TCP/IP协议簇的一个子协议，工作在网络层</li></ul><h3 id="SYN泛洪攻击处理办法"><a href="#SYN泛洪攻击处理办法" class="headerlink" title="SYN泛洪攻击处理办法"></a>SYN泛洪攻击处理办法</h3><ul><li>攻击者利用TCP三次握手的缺陷，大量发生SYN包但是不响应第二次握手，导致服务器产生大量的挂起连接，消耗资源甚至宕机</li><li>可以挂起的连接的超时时间，尽快释放</li><li>对来自同一IP的短时大量连接拒绝响应</li></ul><h3 id="ARP协议-地址解析协议"><a href="#ARP协议-地址解析协议" class="headerlink" title="ARP协议/地址解析协议"></a>ARP协议/地址解析协议</h3><ul><li>以太网中，把IP映射到MAC</li></ul><h3 id="HTTPS以及连接过程"><a href="#HTTPS以及连接过程" class="headerlink" title="HTTPS以及连接过程"></a>HTTPS以及连接过程</h3><ul><li>发送请求</li><li>返回证书</li><li>验证证书生成对称密钥并用服务端公钥加密</li><li>服务端用私钥解密后得到对称密钥，并用堆成密钥加密内容发送给客户端</li><li>客户端解密。。。</li></ul><h3 id="TCP的状态"><a href="#TCP的状态" class="headerlink" title="TCP的状态"></a>TCP的状态</h3><ul><li>建立连接<ul><li>CLOSED：关闭</li><li>LISTEN：监听</li><li>SYN-SENT：发送了SYN请求建立连接</li><li>SYN-RCVD：收到了SYN，发出ACK</li><li>ESTABLISHED：连接建立</li></ul></li><li>释放连接<ul><li>FIN-WAIT-1：发送了关闭请求</li><li>CLOSE-WAIT：收到了FIN请求，等待关闭</li><li>FIN-WAIT-2：收到了ACK</li><li>LAST-ACK：发出了FIN</li><li>TIME-WAIT：收到了SYN，等待2MSL</li><li>CLOSING：同时收到SYN</li></ul></li></ul><h3 id="进程调度算法-FIFO-LRU-权重-RR-多级反馈队列"><a href="#进程调度算法-FIFO-LRU-权重-RR-多级反馈队列" class="headerlink" title="进程调度算法/FIFO LRU 权重 RR 多级反馈队列"></a>进程调度算法/FIFO LRU 权重 RR 多级反馈队列</h3><ul><li>FIFO-先来先服务</li><li>LRU-最近最少使用<ul><li>维护一个最近使用进程的存储数据结构，容量固定，代表最近的使用，同时记录每一个进程的使用次数，新的进程来到时就挑选使用次数最少的替换。</li></ul></li><li>权重优先</li><li>轮转调度</li><li>多级反馈队列<ul><li>Q1-&gt;Q2-&gt;Q3</li></ul></li></ul><h3 id="Redis数据类型-zset等底层"><a href="#Redis数据类型-zset等底层" class="headerlink" title="Redis数据类型/zset等底层"></a>Redis数据类型/zset等底层</h3><ul><li>Redis为什么高效<ul><li>完全基于内存</li><li>数据结构简单</li><li>单线程，避免了上下文切换和竞争</li><li>多路I/O复用，非阻塞IO</li><li>全程使用Hash结构，读取快</li></ul></li><li>数据类型<ul><li>String<ul><li>二进制安全</li></ul></li><li>Hash</li><li>List</li><li>Set<ul><li>哈希实现</li></ul></li><li>Zset<ul><li>有序集合</li><li>排好序</li></ul></li></ul></li></ul><h3 id="B树-B-树-B-树"><a href="#B树-B-树-B-树" class="headerlink" title="B树 B+树 B* 树"></a><strong>B树 B+树 B* 树</strong></h3><ul><li>B树<ul><li>平衡多路查找树</li></ul></li><li>B+树</li><li>B*树</li></ul><h3 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h3><ul><li>cd</li><li>ls<ul><li>ls -l 显示详细信息</li></ul></li><li>cat-读取文件</li><li>rm-删除</li><li>cp</li><li>mv</li><li>mkdir</li><li>kill</li><li>vim</li><li>查询<ul><li>which</li><li>whereis</li><li>locate</li><li>find</li></ul></li><li>chmod</li><li>df</li><li><strong>grep</strong></li><li>ps/process status</li><li>top</li></ul><h3 id="mySQL的引擎极其特点"><a href="#mySQL的引擎极其特点" class="headerlink" title="mySQL的引擎极其特点"></a>mySQL的引擎极其特点</h3><ul><li>innoDB<ul><li>支持事务<ul><li>ACID</li><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li><li>支持行锁</li></ul></li><li>MyISAM<ul><li>支持表锁</li><li>查询快</li></ul></li></ul><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a><strong>乐观锁和悲观锁</strong></h3><ul><li>乐观锁<ul><li>每次读取都认为不会被修改，但是更新的时候会检查，适用于读</li></ul></li><li>悲观锁<ul><li>每次读都认为会被修改，适用于写</li></ul></li></ul><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h3><ul><li>选择</li><li>冒泡</li><li>插入</li><li>归并</li><li>堆</li><li>快速</li><li>基数</li></ul><h3 id="Python中的is和-的区别"><a href="#Python中的is和-的区别" class="headerlink" title="Python中的is和==的区别"></a>Python中的is和==的区别</h3><ul><li>is用id判断，本质是一个东西</li><li>==用value判断，可以不是一个东西</li></ul><h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><ul><li><a href="https://blog.csdn.net/qq_29677867/article/details/91038642">https://blog.csdn.net/qq_29677867/article/details/91038642</a></li></ul><h3 id="mySQL的索引"><a href="#mySQL的索引" class="headerlink" title="mySQL的索引"></a>mySQL的索引</h3><ul><li>数据结构可视化<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li><li>B+</li></ul><h3 id="死锁的条件，原因，解决办法"><a href="#死锁的条件，原因，解决办法" class="headerlink" title="死锁的条件，原因，解决办法"></a>死锁的条件，原因，解决办法</h3><ul><li>条件<ul><li>互斥</li><li>非抢占</li><li>请求和保持</li><li>循环等待</li></ul></li><li>原因<ul><li>竞争</li></ul></li><li>解决办法<ul><li>预防<ul><li>破坏互斥条件</li></ul></li><li>避免<ul><li>银行家算法</li></ul></li><li>检测&amp;接触<ul><li>杀死进程</li></ul></li></ul></li></ul><h3 id="黑盒白盒测试"><a href="#黑盒白盒测试" class="headerlink" title="黑盒白盒测试"></a>黑盒白盒测试</h3><ul><li>黑盒<ul><li>已知产品功能设计规格，可以测试功能</li><li>优点：能够站在用户角度思考测试</li><li>缺点：不能测试程序内部的特定部位</li></ul></li><li>白盒<ul><li>已知产品内部工作过程，测试证明内部操作是否经过检查</li><li>能够检验内部，但无法检验外部特性</li></ul></li></ul><h3 id="进程通信和线程通信"><a href="#进程通信和线程通信" class="headerlink" title="进程通信和线程通信"></a>进程通信和线程通信</h3><ul><li>匿名管道<ul><li>半双工</li><li>仅适用于具有亲缘关系的进程</li><li>面向字节流</li><li>同步<ul><li>多个进程一起多，要么读不到，要么读到完整数据</li></ul></li><li>互斥<ul><li>管道为空，禁止读</li><li>管道为满，禁止写</li></ul></li></ul></li><li>命名管道<ul><li>适用于任何进程之间</li><li>其余同</li></ul></li><li>消息队列<ul><li>本质是内核的一个链表</li><li>适用任何进程</li><li>全双工</li><li>面向数据报文</li><li>内置同步互斥机制</li><li>生命周期随内核</li></ul></li><li>共享内存<ul><li>同一块内存通过页表映射到不同的虚拟地址空间，从而实现不同进程对同一块内存的读写</li><li>全双工</li><li>没有同步互斥</li><li>不存在面向字节流或者数据报的说法，就是一块内存</li></ul></li><li>信号量<ul><li>同步互斥</li></ul></li><li>Socket<ul><li>应用层和传输层之间</li><li>封装了TCP/IP的操作</li></ul></li></ul><h3 id="闭包是啥"><a href="#闭包是啥" class="headerlink" title="闭包是啥"></a>闭包是啥</h3><ul><li>词法作用域</li><li>函数变量</li></ul><h3 id="OSI七层-5层-TCP四层各层功能"><a href="#OSI七层-5层-TCP四层各层功能" class="headerlink" title="OSI七层/5层/TCP四层各层功能"></a>OSI七层/5层/TCP四层各层功能</h3><p><img src="https://tva3.sinaimg.cn/large/a540b426gy1gdmqafzuxkj20id0butd4.jpg" alt="参考"></p><ul><li>主机间的传输<ul><li>应用层    主机之间建立连接</li><li>表示出</li><li>会话层</li></ul></li><li>底层数据流<ul><li>传输层    可靠或不可靠传输，流量控制</li><li>网络层    IP路由</li><li>数据链路层    比特-&gt;字节-&gt;帧</li><li>物理层    比特</li></ul></li></ul><h3 id="元组和列表的区别-Python"><a href="#元组和列表的区别-Python" class="headerlink" title="元组和列表的区别-Python"></a>元组和列表的区别-Python</h3><ul><li>元组不可变</li><li>列表可变</li><li>算法：找出两个链表的第一个公共节点</li><li>算法：最长公共子序列</li></ul><h3 id="set-list-map"><a href="#set-list-map" class="headerlink" title="set list map"></a>set list map</h3><ul><li><strong>List</strong><ul><li>允许重复</li><li>允许多个null</li><li>有序</li><li>ArrayList LinkedList Vector</li></ul></li><li><strong>Set</strong><ul><li>不允许重复</li><li>无序</li><li>只允许一个null</li><li>HashSet LinkedHashSet TreeSet</li></ul></li><li><strong>Map</strong><ul><li>一个接口</li><li>键值</li><li>随意个null值和一个null键</li><li>HashMap LinkedHashMap HashTable TreeMap</li></ul></li></ul><h3 id="http请求-get-post"><a href="#http请求-get-post" class="headerlink" title="http请求/get/post"></a>http请求/get/post</h3><ul><li>GET<ul><li>读取数据</li><li>无副作用</li></ul></li><li>POPST<ul><li>提交数据</li><li>有副作用</li></ul></li></ul><h3 id="缓存雪崩-击穿-穿透"><a href="#缓存雪崩-击穿-穿透" class="headerlink" title="缓存雪崩/击穿/穿透"></a>缓存雪崩/击穿/穿透</h3><ul><li>雪崩-集体失效</li><li>击穿-缓存不存在，但是数据库存在，大量访问数据库导致数据库压力过大</li><li>穿透-缓存和数据库都不存在，通常为恶意攻击</li></ul><h3 id="线程共享进程的什么"><a href="#线程共享进程的什么" class="headerlink" title="线程共享进程的什么"></a>线程共享进程的什么</h3><ul><li>共享<ul><li>代码段</li><li>全局变量</li><li>文件</li></ul></li><li>独享<ul><li>堆栈</li><li>程序计数器</li><li>寄存器</li></ul></li></ul><h3 id="中断，CPU在中断时会干嘛"><a href="#中断，CPU在中断时会干嘛" class="headerlink" title="中断，CPU在中断时会干嘛"></a>中断，CPU在中断时会干嘛</h3><ul><li>当前指令结束</li><li>判断终端类型</li><li>保存现场</li><li>设置为中断模式</li><li>跳转到中断处理程序入口</li><li>执行中断处理程序</li><li>跳转回来</li><li>恢复系现场</li></ul><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><ul><li>滑动窗口</li><li>发送窗口，接收窗口，拥塞窗口的关系</li><li>拥塞窗口的变化规律</li><li>算法：找出和为k的所有数对</li><li>算法：单链表按照中间左右的顺序输出 12345-》32415</li><li>版本号？</li></ul><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><ul><li>应用层</li></ul><h3 id="Redis性能为什么这么高"><a href="#Redis性能为什么这么高" class="headerlink" title="Redis性能为什么这么高"></a>Redis性能为什么这么高</h3><p><a href="https://lkds.github.io/2020/03/31/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E7%82%B9/#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%AB%98%E6%95%88">Redis 为什么高效</a></p><h3 id="事务-特性"><a href="#事务-特性" class="headerlink" title="事务/特性"></a>事务/特性</h3><ul><li>ACID</li></ul><h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select poll epoll"></a>select poll epoll</h3><ul><li>select<ul><li>轮询</li><li>线性</li><li>O（n）</li><li>数量限制</li></ul></li><li>poll<ul><li>轮询</li><li>拷贝到内核</li><li>链表</li><li>无上限</li></ul></li><li>epoll<ul><li>红黑树存储Socket</li><li>双向链表保存就绪态的</li><li>O（1）</li></ul></li><li>算法：10亿个数字取最小的100个/最大堆/大顶堆</li><li>HTTP为什么时TCP<ul><li>主要还是因为TCP面向连接，可靠</li><li>但是也可以使用UDP之类的，因为HTTP是应用层协议，TCP是传输层，只要能达到目的，用什么协议都是可以的</li></ul></li></ul><h3 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h3><ul><li>虚拟地址将所有的存储介质（硬盘和内存）统一规划，实现存储空间的扩容</li><li>物理地址为内存地址</li><li>虚拟地址到物理地址的映射<ul><li>页表</li><li>段</li><li>段页式<ul><li>把程序分段，段内分页</li></ul></li></ul></li><li>碎片<ul><li>外部碎片：由于不连续的地址分配导致存在因为空间太小而无法分配的未分配空间，磁盘整理解决</li><li>内部碎片：已分配的未使用空间，可以不解决</li></ul></li></ul><h3 id="大量数据排序"><a href="#大量数据排序" class="headerlink" title="大量数据排序"></a>大量数据排序</h3><blockquote><p>1、对于内存足够大的大量数据排序，一般来说用归并排序比较好的，因为他的读取次数会比较少（在数据挖掘的理论里面，读取次数越少，排序方法越快），同时是稳定的；<br>2、但是如果内存空间不足，就自然要减少次数了，所以也可以用快速排序，快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>3、也可以利用堆排序，当N很大时，并且有序程度低时，堆排序最快（当N很大时，并且有序程度高时，快速排序最快 ）。</p></blockquote><h3 id="算法：股票问题"><a href="#算法：股票问题" class="headerlink" title="算法：股票问题"></a>算法：股票问题</h3><ul><li>Q1：买卖一次，求最大<ul><li>最大-最小<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> *price,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minPrice = *price;</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(minPrice &gt; *(price+i))&#123;</span><br><span class="line">            minPrice = *(price+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxProfit&lt; (*(price+i)-minPrice))&#123;</span><br><span class="line">            maxProfit = (*(price+i)-minPrice));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>Q2：买卖任意次，求最大<ul><li>前-后的最大值和<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> *price,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*(price)&gt;*(price<span class="number">-1</span>))&#123;</span><br><span class="line">            sum+=*(price)-*(price<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>Q3：买卖k次，求最大<ul><li>动态规划，记录前面的最大差值</li><li>当k足够大时，退化为无限次问题</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>计算机网络</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL简单总结</title>
    <link href="/2020/04/08/STL/"/>
    <url>/2020/04/08/STL/</url>
    
    <content type="html"><![CDATA[<h2 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h2><blockquote><p>Standard Template Library，标准模板库，是C++的标准库之一，一套基于模板的容器类库，还包括许多常用的算法，提高了程序开发效率和复用性。STL包含6大部件：容器、迭代器、算法、仿函数、适配器和空间配置器。</p></blockquote><ol><li>容器：容纳一组元素的对象。</li><li>迭代器：提供一种访问容器中每个元素的方法。</li><li>函数对象：一个行为类似函数的对象，调用它就像调用函数一样。</li><li>算法：包括查找算法、排序算法等等。</li><li>适配器：用来修饰容器等，比如queue和stack，底层借助了deque。</li><li>空间配置器：负责空间配置和管理。</li></ol><h2 id="容器简单特性"><a href="#容器简单特性" class="headerlink" title="容器简单特性"></a>容器简单特性</h2><ol><li>vector：可变大小的数组</li><li>deque：双端队列，支持快速随机访问</li><li>list：双向链表</li><li>priority_queue：堆实现，按照优先级排序</li><li>map：键值对，底层RB Tree 有序 不允许重复的键</li><li>set：只有键，底层RB Tree 有序 不允许重复的键</li><li>unordered_map/set：哈希表实现的map/set</li></ol><h2 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h2><h4 id="vector的reserve和resize的区别"><a href="#vector的reserve和resize的区别" class="headerlink" title="vector的reserve和resize的区别"></a>vector的reserve和resize的区别</h4><p><strong>1. reserve()</strong></p><p>它的函数原型是这样的：</p><p>void reserve(size_type n);<br>对于n值的大小，分两种情况：</p><p>（1）如果n大于容器现有的容量（capacity），比如你容器原来是100的容量，我现在指定n=200，那么就需要在自由内存区为整个容器重新分配一块新的更大的连续空间【因为vector是顺序容器，所以存储空间是连续的，如果之前的存储空间不够了，必须这样做】，然后将容器内所有的有效元素从旧位置全部复制到新位置，这个过程是调用拷贝构造函数，然后释放旧位置的所有存储空间，并调整容器的元素位置指示器。所以reserve的时候如果n比原来的大，结果只是让容器的冗余容量（即没有分配元素的存储区）变大，容器的实际大小，即元素个数并没有改变。</p><p>（2）如果n小于容器原来的容量，那么这个函数什么作用都没有。相当于白调用了。</p><p><strong>2. resize()</strong></p><p>它的函数原型是这样的：</p><p>void resize(size_type n, const T&amp; c = T());<br>其中n是要保留的元素个数，如果是要新增元素的话，c则是新增元素的默认初始值。</p><p>对于n值的大小，分三种情况：</p><p>（1）如果n大于容器当前的大小（即容器的size，这里和capacity无关），则在容器的末尾插入n-size()个初始值为c的元素；如果没有指定初始值，那就元素类型的默认构造函数来初始化。</p><p>（2）如果n小于容器当前的大小，则删除末尾的size()-n个元素，这样就导致容器的大小变了，size 变小了。但是这种类型的容器在删除一个元素的时候并不会释放元素本身的内存空间【这也是为了保留这块空间以避免将来要插入新元素的时候又要进行存储空间重分配】，所以容器的容量即capacity其实是没有改变的。</p><p>（3）n等于容器当前的大小，则什么也不做。</p><p>显然，reserve和resize的共同点就是：都不缩减容器本身的容量。即对内存空间并没有影响。那么要是当你觉得容器的容量太多的时候，应该如何缩减容量呢。这时候需要用到一个利用swap函数的技巧。</p><h4 id="vector中size和capacity的区别"><a href="#vector中size和capacity的区别" class="headerlink" title="vector中size和capacity的区别"></a>vector中size和capacity的区别</h4><ul><li>size表示当前vector中有多少个元素（finish - start）</li><li>capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）。</li></ul><h4 id="vector迭代器失效的情况"><a href="#vector迭代器失效的情况" class="headerlink" title="vector迭代器失效的情况"></a>vector迭代器失效的情况</h4><ul><li><p>当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。</p></li><li><p>当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。</p></li></ul><h4 id="vector扩容"><a href="#vector扩容" class="headerlink" title="vector扩容"></a>vector扩容</h4><ul><li>为什么要成倍增长？<br>时间复杂度O（1）</li><li>为什么是1.5或2？<br>1-2之间的话，之前分配的空间可以直接使用</li></ul><h4 id="vector-deque-list的使用场景"><a href="#vector-deque-list的使用场景" class="headerlink" title="vector deque list的使用场景"></a>vector deque list的使用场景</h4><ul><li>vector-读多写少</li><li>list-写多读少</li><li>deque-从两端操作</li></ul><h4 id="unordered-map-和-map的区别以及使用场景？"><a href="#unordered-map-和-map的区别以及使用场景？" class="headerlink" title="unordered_map 和 map的区别以及使用场景？"></a>unordered_map 和 map的区别以及使用场景？</h4><ul><li>两者存储的结构不一样，unordered_map使用的是hash表作为底层存储，而map使用红黑树作为底层数据结构。所以unordered_map查找速度比map快，但是因为hash表的特点，内存占用也要高。</li><li>同时map里面的元素是有序的，但是unorderedmap是无序的。</li><li>那么综上所述，当我们有频繁查找的需求并且对内存要求不严格时考虑使用unorderedmap，如果希望数据有序，或者对内存要求严格就用map</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://blog.csdn.net/daaikuaichuan/article/details/80717222">STL详解及常见面试题</a><br>[2] <a href="https://blog.csdn.net/weixin_43762200/article/details/85319689">STL容器特点对比</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>STL</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试常考点</title>
    <link href="/2020/03/31/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E7%82%B9/"/>
    <url>/2020/03/31/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="进程线程区别"><a href="#进程线程区别" class="headerlink" title="进程线程区别"></a>进程线程区别</h3><p>简单来讲,进程是操作系统进行资源分配的基本单位,线程是操作系统调度和执行的基本单位.</p><ul><li><p>进程有其自己的地址空间,包括代码段和数据段,打开文件描述符,PCB块,进程ID等</p></li><li><p>进程之间不能共享资源,而属于同一个进程的线程之间则可以共享资源.如地址空间等,但是线程有自己独有的栈和栈指针,程序计数器等.<br><img src="https://pic2.zhimg.com/v2-0286f1c2a82b32a8aad5bf42fb04f1f2_r.jpg" alt="线程&amp;进程&amp;协程1"><br><img src="https://pic4.zhimg.com/v2-f1380c8d9bd70517a8390c707cadbb80_r.jpg" alt="2"><br><img src="https://pic3.zhimg.com/v2-71da6e6200b101f7cca936f72ff4ffcc_r.jpg" alt="3"></p><center><a link="https://www.zhihu.com/question/25532384/answer/720946992">线程和进程的区别是什么？ - 无与童比的回答 - 知乎</a></center><br></li><li><p><strong>为什么要有线程,直接用进程不行吗?</strong><br>因为进程不够轻量,进程的上下文切换,资源分配等操作需要消耗CPU,在多任务调度中频繁切换会带来比较大的性能损耗,因此就需要再把进程细分,就出现了线程.<br><a href="https://my.oschina.net/cnyinlinux/blog/422207">Linux进程与线程的区别</a></p></li></ul><h3 id="URL到页面渲染"><a href="#URL到页面渲染" class="headerlink" title="URL到页面渲染"></a>URL到页面渲染</h3><p><a href="https://segmentfault.com/a/1190000009353010">彻底理解从输入URL与页面展现</a></p><ul><li><p>第一步进行域名解析,也就是查询域名获取IP地址</p></li><li><p>第二步拿到IP后就发起HTTP/HTTPS请求,进行TCP三次握手与服务器建立连接</p></li><li><p>发送HTTP(s)请求,服务器响应HTTP(s)请求,返回一个HTTP响应</p></li><li><p>浏览器获取响应后得到HTML代码加载到浏览器进行解析,渲染</p></li><li><p>域名解析过程<br>查找浏览器缓存 ——&gt; 查找操作系统缓存 ——&gt; 查找路由器缓存 ——&gt; 查找本地DNS缓存 ——&gt; 递归查询<br>（DNS：域名和IP地址相互映射的一个分布式数据库）<br><img src="https://image-static.segmentfault.com/364/224/3642243792-5911b7a9a4a24_articlex" alt="DNS查询" title="DNS查询"></p></li><li><p><strong>HTTP常见状态码</strong><br>HTTP的状态码可以分为5种类型1xx表示消息提示,2xx表示成功接收,3xx重定向,4xx请求错误,5xx服务器错误.比较常见的有200 OK,301永久重定向,302临时重定向.401未授权的访问,403 拒绝访问,404找不到网页,502 网关错误,联系不到后台服务器,503 Service Unavailable,504网关超时等.<br><a href="https://www.cnblogs.com/gxywb/p/11434649.html">HTTP状态码</a></p></li><li><p><strong>HTTP为什么要用TCP,用UDP不行吗?</strong><br>因为TCP是面向连接的可靠传输,UDP是面向无连接的不可靠传输,UDP比较适合于对于丢包等情况不敏感,对时延要求较高的大量数据传送过程,显然HTTP不属于这一类,相反,HTTP应该对可靠有一定的要求,不然网页的程序将错乱百出.事实上,只要能够保证可靠传输,那么选什么协议都是可以考虑的.</p></li></ul><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul><li><p><strong>虚函数的作用</strong><br>C++通过Virtual关键字声明一个虚函数,实现使用指向子类实例的父类指针来调用子类的方法.提供了运行时多态.</p></li><li><p><strong>虚函数和纯虚函数</strong><br>纯虚函数相当于声明了一个接口,继承这个类的子类都需要实现这个接口,起到一个规范作用.</p></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是指同一种事物的不同状态,可以分为静态多态和动态多态两种,静态多态函数重载,泛型等,其具体的状态再编译时就已经确定,而动态多态则主要依靠虚函数,继承等来实现,其具体的状态需要在运行时才能确定.</p><ul><li><strong>多态的优点</strong><br>提高了代码的复用性,程序的扩展性和维护性.</li><li><strong>缺点</strong><br>程序运行效率受到影响,以及多余空间结构开销.</li></ul><h3 id="多继承及其问题"><a href="#多继承及其问题" class="headerlink" title="多继承及其问题"></a>多继承及其问题</h3><p>多继承就是同一个对象继承自多个父类<br>会产生问题,比如菱形继承,不仅会出现二义性,而且在子类中还会保存多个父类的副本,浪费空间.解决办法,对于二义性,可以使用作用域限定,对于多个副本,可以使用虚继承.</p><p><img src="https://img-blog.csdnimg.cn/20190116230607742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW8zNDA0,size_16,color_FFFFFF,t_70" alt="C++ 继承"></p><h3 id="TCP三次握手-amp-四次挥手"><a href="#TCP三次握手-amp-四次挥手" class="headerlink" title="TCP三次握手&amp;四次挥手"></a>TCP三次握手&amp;四次挥手</h3><ul><li><p><strong>三次握手过程</strong><br>答:假设有2个连接方AB,其中A处于CLOSED状态,B处于LISTEN状态,通常两端分别为客户端和服务端,如果A要发起一个TCP连接,那么过程如下</p><ul><li>A向B发送一个SYN同步信号表示要建立连接,同时带上了其随机生成生成初始序列号,ISN,然后进入到SYN_SNET状态.</li><li>B收到后回复一个SYN同步信号和ACK信号表示接收到了A发来的请求,也带上其随机生成的初始序列号然后进入SYN_RECV状态</li><li>A收到B发来的SYN信号后,就会回复一个ACK用以确认.然后进入到ESTABLISHED单方面连接建立状态.B收到ACK后也进入ESTABLISHED状态,连接建立完成.<br><img src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" title="3次握手"></li></ul></li><li><p><strong>为什么要三次握手?两次不行吗?</strong></p><ul><li>简单来说,三次握手可以避免失效的SYN请求带来资源浪费.当A第一次发送的SYN没有被B收到时,A会周期性的重发,这样哪些还在网络中的SYN请求就可能会到达B意外建立一个连接,导致资源的浪费.</li><li>更进一步来讲,三次握手是解决不可靠网络环境所需要的少次数.TCP依靠发送字节流的序列号来保证数据的可靠传输,那么在传输开始之前传输双方就要互相告诉各自的起始序列号,二次握手情况下,A能够确认B已经知道了自己的序列号,但是B却没有办法确认A收到了自己的序列号,因此通信不能完整进行,因此需要三次握手.</li></ul></li><li><p>如果第一次握手丢失,会怎么样?</p><ul><li>A一直周期性的发送SYN同步信号知道收到回复</li></ul></li><li><p>如果第二次握手丢失?</p><ul><li>B会一直周期性的发送SYN+ACK信号,直到收到回复</li></ul></li><li><p><strong>如果第三次握手丢失?</strong><br>第三次丢失的情况下,A已经单方面建立连接了,可以分为以下几个情况</p><ul><li>A没有数据发送,那么B收不到回复就会周期性重传SYN+ACK包,直到收到确认</li><li>A有数据发送,那么B收到A的数据+ACK之后,就可以完成确认进入ESTABLISHED状态</li></ul></li><li><p><strong>四次挥手</strong></p><ul><li>A发送FIN到B进入FIN-WAIT1</li><li>B收到FIN后回复一个ACK确认进入CLOSE-WAIT状态</li><li>A收到后进入FIN-WAIT2状态</li><li>B发送完数据后,再发送一个FIN表示关闭进入LAST-ACK状态</li><li>A收到FIN后发送一个ACK用以确认然后进入TIME-WAIT状态,等待2MSL后就进入CLOSED状态</li><li>B收到ACK后就会进入CLOSE状态<br><img src="https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" title="4次挥手"></li></ul></li><li><p><strong>为什么要等到2MSL?</strong><br>为了防止最后发出的ACK确认包丢失导致服务端无法正常关闭.当A发出的ACK包超时后,B会周期性发送SYN包到A,再2MSL内可以保证A能收到该包并作出响应.</p></li><li><p>连接建立后,客户端故障<br>服务端保活机制,一段时间无消息后会发生探测消息,多次未回应就断开</p></li></ul><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><ul><li><p>乐观锁,顾名思义,就是很乐观,每次去读取数据都认为不会有人来修改数据,因此不会上锁,但是在更新数据的时候需要判断期间数据是否被修改过.常用的实现机制是版本号,时间戳,CAS等</p></li><li><p>悲观锁就是每次读取数据都认为别人会修改,所以会上锁,直到操作完成.数据库中的锁,JAVA中的synchronized都是悲观锁的体现.</p></li><li><p><strong>适用场景</strong><br>显然,乐观锁适用于写比较少,读比较多的情况下,能够提高系统的吞吐量.<br>悲观锁则适用于写比较多的情况.</p></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><a href="https://www.cnblogs.com/limuzi1994/p/9684083.html">mysql的事务四个特性以及事务的四个隔离级别</a><br>事务是访问并可能操作各种数据项的一个数据库序列,并且这些操作不可分割.<br>事物有以下四个特定,第一个就是原子性,即要么全部执行,要么全部不执行.第二个就是一致性,也就是事务的执行必须保证数据的完整性,有点类似于守恒的意思,比如转账,转账前后钱的总数是一致的.第三个就是隔离性,也就是多个事务之间是互相隔离的,不能被干扰.最后是持久性,即数据一但写入,就一直存在,即使是发生故障.</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li><p>更新丢失I II</p><ul><li>I 后面的事务撤销导致前面的更新丢失</li><li>II 后面的事务覆盖了前面的更新导致丢失</li><li>solution:加锁</li></ul></li><li><p>脏读</p><ul><li>读取到已经回滚的数据</li><li>solution:提交前不能读取修改过的数据</li></ul></li><li><p>不可重复读</p><ul><li>前后两次读取同一数据结果不一致</li><li>solution:修改提交前不允许</li></ul></li><li><p>幻读</p><ul><li>前后两次查询记录条目不一样</li><li>操作事务完成之前,任何其它事务都不能进行.</li></ul></li><li><p>Read Uncommitted/读未提交</p></li><li><p>Read committed/授权读取、读提交</p></li><li><p>Repeatable read/可重复读取</p></li><li><p>Serializable/序列化<br><img src="https://img-blog.csdn.net/20170725154818659" title="隔离级别"></p></li></ul><h3 id="Redis为什么高效"><a href="#Redis为什么高效" class="headerlink" title="Redis为什么高效"></a>Redis为什么高效</h3><ul><li>首先，Redis是完全面向内存的，内存的读取速度要远高于硬盘</li><li>Redis的数据结构简单，且是专门设计的</li><li>其次，Redis是单线程的，避免了上下文切换和竞争条件，加锁、释放锁等额外条件</li><li>然后，Redis使用了多路复用IO，非阻塞式IO。<a href="http://blog.chinaunix.net/uid-28458801-id-4464639.html">网络IO模型：同步IO和异步IO，阻塞IO和非阻塞IO</a></li></ul><h3 id="select-poll-epoll（I-O多路复用的三种机制）"><a href="#select-poll-epoll（I-O多路复用的三种机制）" class="headerlink" title="select poll epoll（I/O多路复用的三种机制）"></a>select poll epoll（I/O多路复用的三种机制）</h3><p><a href="https://www.jianshu.com/p/397449cadc9a">IO多路复用的三种机制Select，Poll，Epoll</a></p><ul><li>select：维护一个fd_set的数据结构，实际上是一个长整型数组，每个元素都和一个打开的文件句柄联系。进程通过调用select来遍历整个数组获取被激活的IO从而实现在一个进程内部处理多个IO的目的。问题：需要把数组从用户态复制到内核态，同时还需要遍历，且数组有最大的长度限制。</li><li>poll：把select的数据结构从数组换成了链表，解决了最大长度限制的问题。</li><li>epoll：采用的是哈希表实现，当IO被激活时，系统将其加入一个就绪队列并通知相关进程，相关进程只需要遍历这部分就绪进程就行了。大大提高了效率。并且epoll只需要一次的fd拷贝，也没有最大数量限制。</li></ul><p><img src="https://tvax3.sinaimg.cn/large/a540b426gy1gddh9h4da3j20oi0i3q4e.jpg" title="对比"></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>操作系统</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>django-channels开发日记</title>
    <link href="/2020/02/13/django-channels/"/>
    <url>/2020/02/13/django-channels/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原本打算用dwebsocket从头开始撸个简单的通讯框架，写了一点简单的通信功能，感觉还行。但是偶尔去作者的<a href="https://github.com/duanhongyi/dwebsocket">GitHub</a>时发现作者是国人，原以为沟通会比较好，但是查看issue的时候发现很多issue都没有回复就被草草的关闭了。本来以为dwebsocket是个比较成熟的项目，但其实只有200余个star，顿时心生失落。<br>几天后，收到了消息模块写完了的消息，pull下来一看，挺专业。但是框架用的是django-channels。<br>这个django-channels，我也早有耳闻。是django官方推荐的websocket通信框架，但是django的东西几乎都有个特点，有门槛。但是本着不重复造轮子的名言我就开始看看django-channels。</p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>之前几天陆陆续续看了一下，还是老样子，摸不着头脑，连如何使用都一时找不到由头。代码借鉴了一个现有的GitHub开源项目<a href="https://github.com/michwh/onehome-server">onehome</a>，从而导致代码和我们的项目的吻合度不高，阅读有些障碍。<br>于是今天粗略的看了一下django-channels的<a href="https://channels.readthedocs.io/en/latest/index.html">官方文档</a>，发现主要的内容其实不算多。大致看了之后就着手修改、运行已有的代码。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>按照网上的教程（CSDN、简书），尝试跑起来，连接。发现在Chanel_layer那里死活连不上，后来发现其实不仅需要这个框架，还需要<a href="https://github.com/microsoftarchive/redis/releases">redis</a>的支持。<br>安装好redis后发现能够连接上，但是后来又不行。调试了一上午，发现是断点的锅，把断点打在了一个await语句上。导致正常运行出错。</p><h1 id="鉴权-amp-amp-认证"><a href="#鉴权-amp-amp-认证" class="headerlink" title="鉴权 &amp;&amp; 认证"></a>鉴权 &amp;&amp; 认证</h1><p>由于项目使用的是JWT的鉴权机制，而channels自带的是session的鉴权，所以需要自己手动实现鉴权。此处参考了<a href="https://www.jianshu.com/u/85a919706c15">EarthChen</a>的<a href="https://www.jianshu.com/p/3de90e457bb4">Django使用Channels实现websocket</a></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>django</tag>
      
      <tag>django-channels</tag>
      
      <tag>采声</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>drf</title>
    <link href="/2019/11/07/drf/"/>
    <url>/2019/11/07/drf/</url>
    
    <content type="html"><![CDATA[<h2 id="DRF重写"><a href="#DRF重写" class="headerlink" title="DRF重写"></a>DRF重写</h2><h3 id="serializer"><a href="#serializer" class="headerlink" title="serializer"></a>serializer</h3><ul><li><p>create(self, validated_data)<br>利用validated_data创建实例<br>返货一个serializer实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">self, validated_data</span>):</span></span><br><span class="line"><span class="comment">#重载</span></span><br><span class="line"><span class="comment"># print(self.context)</span></span><br><span class="line"><span class="built_in">print</span>(validated_data)</span><br><span class="line">user = <span class="built_in">super</span>(userSerializers, self).create(validated_data=validated_data)</span><br><span class="line">user.set_password(validated_data[<span class="string">&#x27;password&#x27;</span>])</span><br><span class="line">user.save()</span><br><span class="line"><span class="keyword">return</span> user</span><br></pre></td></tr></table></figure></li><li><p>update(self, instance, validated_data)<br>setattr(instance,attr,value)修改现有实例</p></li></ul><h3 id="viewSet"><a href="#viewSet" class="headerlink" title="viewSet"></a>viewSet</h3><ul><li>perform_create(self, serializer)<br>执行创建,serializer为已经实例化的serializer<br>可以通过serializer.save()修改或者添加数据<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_create</span>(<span class="params">self,serializer</span>):</span></span><br><span class="line">user = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> self.request <span class="keyword">and</span> <span class="built_in">hasattr</span>(self.request,<span class="string">&#x27;user&#x27;</span>):<span class="comment">#必须要有request并且request里面有user</span></span><br><span class="line">    user = self.request.user</span><br><span class="line"><span class="keyword">else</span>:<span class="comment">#否则不予创建</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">serializer.save(user=user)</span><br></pre></td></tr></table></figure></li><li>perform_update(self,instance)同</li><li>perform_delete(self,instance)同<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重写destroy，删除联系的时候likeCount--</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_destroy</span>(<span class="params">self,instance</span>):</span></span><br><span class="line">    post = instance.post</span><br><span class="line">    post.replyCount-=<span class="number">1</span></span><br><span class="line">    post.save()</span><br><span class="line">    instance.delete()</span><br></pre></td></tr></table></figure><h2 id="action修饰器"><a href="#action修饰器" class="headerlink" title="@action修饰器"></a>@action修饰器</h2></li></ul><p>@action(methods=[‘get’],detail=True)<br>定义一个动作,执行不同的操作,detail指明是否对单个实例</p><ul><li>获取列表<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@action(<span class="params">methods=[<span class="string">&#x27;get&#x27;</span>],detail=<span class="literal">False</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMyPost</span>(<span class="params">self,request</span>):</span></span><br><span class="line">    <span class="comment">#保证又权限</span></span><br><span class="line">    queryset = self.get_queryset().<span class="built_in">filter</span>(user=request.user.<span class="built_in">id</span>)</span><br><span class="line">    serializer = self.get_serializer(queryset,many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure></li><li>修改数据<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除或者添加关注</span></span><br><span class="line"><span class="meta">@action(<span class="params">methods=[<span class="string">&#x27;post&#x27;</span>],detail=<span class="literal">True</span></span>) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addOrDeleteFollow</span>(<span class="params">self,request,pk=<span class="literal">None</span></span>):</span></span><br><span class="line">    obj = self.get_object()</span><br><span class="line">    <span class="comment"># print(request.data)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        targetUserID = request.data[<span class="string">&#x27;targetUser&#x27;</span>]<span class="comment">#传id</span></span><br><span class="line">        <span class="keyword">if</span> targetUserID:</span><br><span class="line">            targetUser = User.objects.get(<span class="built_in">id</span>=targetUserID)</span><br><span class="line">            <span class="keyword">if</span> obj.following.<span class="built_in">filter</span>(pk = targetUserID):</span><br><span class="line">                obj.following.remove(targetUser)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                obj.following.add(targetUser)            </span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;success&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">&#x27;msg&#x27;</span>:<span class="string">&#x27;fail&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>django</tag>
      
      <tag>rest-framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>来世聚散</title>
    <link href="/2019/01/27/%E6%9D%A5%E4%B8%96%E8%81%9A%E6%95%A3/"/>
    <url>/2019/01/27/%E6%9D%A5%E4%B8%96%E8%81%9A%E6%95%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="浮云吹作雪"><a href="#浮云吹作雪" class="headerlink" title="浮云吹作雪"></a>浮云吹作雪</h1><blockquote><p>月，阴晴圆缺，如你的发梢</p></blockquote><p>转眼又是如此的岁末年初，对于年这个从古至今深深烙印在中国人脑海记忆深处的印记，我似乎是丧失了只停留在儿时的敏锐的嗅觉<br>转而觉得难以忘却的，更多的化成了一种时过境迁，命途难测<br>感时伤事的道理，竟是如此的令人萧条<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1548591653184&di=7a5fb12124ca3e891fa552178fed8b2f&imgtype=0&src=http://5b0988e595225.cdn.sohucs.com/q_70,c_zoom,w_640/images/20190111/4066627e6c364360b5eef23caa369cd0.jpeg" alt="寒冰冻，珠钗掉" title="珠钗掉"></p><h1 id="世味煮成茶"><a href="#世味煮成茶" class="headerlink" title="世味煮成茶"></a>世味煮成茶</h1><blockquote><p>结，年年今夜，悄悄地缠绕</p></blockquote><p>说不清楚，依旧是那样的繁复纠缠地事务。却没了一种完成后的依托，它的经由也是如此的凄冷。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1548599683372&di=29881c1f7cee12899f26b23741695f91&imgtype=0&src=http://pic.rmb.bdstatic.com/49cf8854a349611ec5198d5ccb3dc93b.jpeg" alt="花飞尽 草无垠" title="花飞尽"></p>]]></content>
    
    
    <categories>
      
      <category>文辞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>聚 散</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>望春归</title>
    <link href="/2019/01/14/%E2%80%9C%E6%9C%9B%E6%98%A5%E5%BD%92/"/>
    <url>/2019/01/14/%E2%80%9C%E6%9C%9B%E6%98%A5%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>细雨斜风作晓寒<br>淡烟疏柳媚晴滩<br>入淮清洛渐漫漫<br>雪沫乳花浮午盏<br>蓼茸蒿笋试春盘<br>人间有味是清欢</p></blockquote><h2 id="细雨"><a href="#细雨" class="headerlink" title="细雨"></a>细雨</h2><p>长廊的尽头是被风拂过的翠绿 少了些许红艳的点缀 但却丝毫没有单调的气氛<br>只要有那些晶莹透亮的山风细雨就满足了</p><p><img src="/img/xfxy.jpg" alt="细雨斜风作晓寒" title="细雨斜风作晓寒"></p><h2 id="乳花"><a href="#乳花" class="headerlink" title="乳花"></a>乳花</h2><p>我站立在无尽的白桦林的边缘，漫天的黄沙是我的眼睛蒙上了一层浑浊的水雾。<br>我不知道哪座山背后栖息着来自故乡的啼鸣，我只是走着，走着。</p><p><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/130/2/thumb.jpg" alt="雪沫乳花浮午盏" title="雪沫乳花浮午盏"></p><h2 id="清欢"><a href="#清欢" class="headerlink" title="清欢"></a>清欢</h2><p>最好是有阳光的 梳着无限细分的发丝的 清圆的脸<br><img src="/img/rjyw.jpg" alt="人间有味是清欢" title="人间有味是清欢"></p><h1 id="徒步亦是逆旅-从来依依不舍"><a href="#徒步亦是逆旅-从来依依不舍" class="headerlink" title="徒步亦是逆旅 从来依依不舍"></a>徒步亦是逆旅 从来依依不舍</h1>]]></content>
    
    
    <categories>
      
      <category>文辞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>春</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Another Day</title>
    <link href="/2019/01/12/Another-Day/"/>
    <url>/2019/01/12/Another-Day/</url>
    
    <content type="html"><![CDATA[<h1 id="别后有天"><a href="#别后有天" class="headerlink" title="别后有天"></a>别后有天</h1><h2 id="相见时难别亦难"><a href="#相见时难别亦难" class="headerlink" title="相见时难别亦难"></a>相见时难别亦难</h2><blockquote><p>一年将尽夜 万里未归人</p></blockquote><p><img src="https://cdn.pixabay.com/photo/2018/11/29/23/32/dawn-3846778__340.jpg" alt="风起于青萍 坠于草莽" title="微茫天地"></p><p><img src="https://cdn.magdeleine.co/wp-content/uploads/2018/12/winter_frost_9-860x573.jpg" alt="清霜最醉" title="寒芒"></p><p>辗转于天地，莫非时间一个回首<br><a href="http://cqu.fnzs.tk/">CQU Market</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Like(You)</span><br><span class="line">&#123;</span><br><span class="line">alert(&quot;Just For You!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>文辞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Passage</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
